{
  "atomspace/opencog/atoms/atom_types/NameServer.cc": {
    "alt_operators": [
      {
        "line": 88,
        "operator": "or",
        "replacement": "||",
        "code": "_tmod++;"
      },
      {
        "line": 90,
        "operator": "and",
        "replacement": "&&",
        "code": "return false;"
      },
      {
        "line": 195,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 195,
        "operator": "or",
        "replacement": "||",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/base/Atom.cc": {
    "alt_operators": [
      {
        "line": 122,
        "operator": "and",
        "replacement": "&&",
        "code": "// predicate is used directly with setValue()."
      },
      {
        "line": 156,
        "operator": "and",
        "replacement": "&&",
        "code": "KVP_UNIQUE_LOCK;"
      },
      {
        "line": 183,
        "operator": "not",
        "replacement": "!",
        "code": "auto pr = _values.find(truth_key());"
      },
      {
        "line": 190,
        "operator": "not",
        "replacement": "!",
        "code": "if (_values.end() != pr) return pr->second;"
      },
      {
        "line": 233,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 239,
        "operator": "and",
        "replacement": "&&",
        "code": "nv = createFloatValue(FLOAT_VALUE, count);"
      },
      {
        "line": 240,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 266,
        "operator": "and",
        "replacement": "&&",
        "code": "FloatValuePtr fv(FloatValueCast(pap));"
      },
      {
        "line": 386,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 458,
        "operator": "not",
        "replacement": "!",
        "code": "///"
      },
      {
        "line": 479,
        "operator": "not",
        "replacement": "!",
        "code": "if (! (_flags.load() & USE_ISET_FLAG)) return;"
      },
      {
        "line": 486,
        "operator": "not",
        "replacement": "!",
        "code": "/// Add an atom to the incoming set."
      },
      {
        "line": 529,
        "operator": "not",
        "replacement": "!",
        "code": "// set drops to zero size. There is really no reason to actually"
      },
      {
        "line": 554,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 556,
        "operator": "not",
        "replacement": "!",
        "code": "/// will see either one or the other, but ! both/neither in"
      },
      {
        "line": 562,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 562,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 569,
        "operator": "not",
        "replacement": "!",
        "code": "bucket = iset.find(nt);"
      },
      {
        "line": 571,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 571,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 584,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 596,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 607,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 672,
        "operator": "not",
        "replacement": "!",
        "code": "AtomSpace* eva = _atom_space;"
      },
      {
        "line": 674,
        "operator": "not",
        "replacement": "!",
        "code": "// If we are a FRAME, then it is possible that the owning"
      },
      {
        "line": 674,
        "operator": "and",
        "replacement": "&&",
        "code": "// If we are a FRAME, then it is possible that the owning"
      },
      {
        "line": 695,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 708,
        "operator": "not",
        "replacement": "!",
        "code": "// deduplicate the incoming set."
      },
      {
        "line": 722,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 724,
        "operator": "and",
        "replacement": "&&",
        "code": "// Prevent update of set while a copy is being made."
      },
      {
        "line": 742,
        "operator": "not",
        "replacement": "!",
        "code": "for (const auto& bucket : iset)"
      },
      {
        "line": 755,
        "operator": "not",
        "replacement": "!",
        "code": "if (as and ! nameserver().isA(_type, FRAME))"
      },
      {
        "line": 768,
        "operator": "not",
        "replacement": "!",
        "code": "return retset;"
      },
      {
        "line": 772,
        "operator": "not",
        "replacement": "!",
        "code": "INCOMING_SHARED_LOCK;"
      },
      {
        "line": 772,
        "operator": "and",
        "replacement": "&&",
        "code": "INCOMING_SHARED_LOCK;"
      },
      {
        "line": 784,
        "operator": "not",
        "replacement": "!",
        "code": "// Lock to prevent updates of the set of atoms."
      },
      {
        "line": 795,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "atomspace/opencog/atoms/base/Atom.h": {
    "alt_operators": [
      {
        "line": 63,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 67,
        "operator": "not",
        "replacement": "!",
        "code": "// the deleted key. So provide that, setting it to zero."
      },
      {
        "line": 173,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 264,
        "operator": "not",
        "replacement": "!",
        "code": "*    enable USE_BARE_BACKPOINTER to get this."
      },
      {
        "line": 264,
        "operator": "or",
        "replacement": "||",
        "code": "*    enable USE_BARE_BACKPOINTER to get this."
      },
      {
        "line": 476,
        "operator": "not",
        "replacement": "!",
        "code": "/// At this time, we use a 64-bit non-cryptographic hash: it is"
      },
      {
        "line": 539,
        "operator": "not",
        "replacement": "!",
        "code": "virtual ValuePtr execute(void) { return execute(_atom_space, false); }"
      }
    ]
  },
  "atomspace/opencog/atoms/base/ClassServer.cc": {
    "alt_operators": [
      {
        "line": 44,
        "operator": "and",
        "replacement": "&&",
        "code": "{}"
      },
      {
        "line": 53,
        "operator": "not",
        "replacement": "!",
        "code": "/// order, and still have them mirror the correct type hierarchy."
      },
      {
        "line": 93,
        "operator": "and",
        "replacement": "&&",
        "code": "// an error, we can't throw an exception. (Well, we can, but"
      },
      {
        "line": 152,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 152,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/base/Handle.cc": {
    "alt_operators": [
      {
        "line": 86,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 99,
        "operator": "not",
        "replacement": "!",
        "code": "if (h.get() == nullptr) return false;"
      },
      {
        "line": 112,
        "operator": "not",
        "replacement": "!",
        "code": "return true;"
      },
      {
        "line": 334,
        "operator": "not",
        "replacement": "!",
        "code": "std::stringstream ss;"
      }
    ]
  },
  "atomspace/opencog/atoms/base/Handle.h": {
    "alt_operators": [
      {
        "line": 369,
        "operator": "or",
        "replacement": "||",
        "code": "typename std::enable_if< std::is_base_of<Atom, T>::value, std::shared_ptr<T> >::type"
      },
      {
        "line": 433,
        "operator": "not",
        "replacement": "!",
        "code": "typedef opencog::HandlePair first_argument;"
      }
    ]
  },
  "atomspace/opencog/atoms/base/Link.cc": {
    "alt_operators": [
      {
        "line": 76,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 76,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/base/Node.cc": {
    "alt_operators": [
      {
        "line": 34,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 35,
        "operator": "not",
        "replacement": "!",
        "code": "#define MASK(mask,val) (((*ptr) & mask) == val)"
      },
      {
        "line": 36,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 47,
        "operator": "not",
        "replacement": "!",
        "code": "ptr++; continue;"
      }
    ]
  },
  "atomspace/opencog/atoms/columnvec/FloatColumn.cc": {
    "alt_operators": [
      {
        "line": 73,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/columnvec/LinkColumn.cc": {
    "alt_operators": [
      {
        "line": 54,
        "operator": "not",
        "replacement": "!",
        "code": "vseq.emplace_back(vp);"
      }
    ]
  },
  "atomspace/opencog/atoms/columnvec/SexprColumn.cc": {
    "alt_operators": [
      {
        "line": 41,
        "operator": "not",
        "replacement": "!",
        "code": "size_t sz = _outgoing.size();"
      }
    ]
  },
  "atomspace/opencog/atoms/columnvec/TransposeColumn.cc": {
    "alt_operators": [
      {
        "line": 72,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/core/AbsentLink.cc": {
    "alt_operators": [
      {
        "line": 40,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/core/Checkers.cc": {
    "alt_operators": [
      {
        "line": 81,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 98,
        "operator": "not",
        "replacement": "!",
        "code": "// This is used by PLN to avoid type-checking."
      },
      {
        "line": 127,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 135,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 152,
        "operator": "not",
        "replacement": "!",
        "code": "if (QUOTE_LINK == t) continue;"
      }
    ]
  },
  "atomspace/opencog/atoms/core/CondLink.cc": {
    "alt_operators": [
      {
        "line": 37,
        "operator": "and",
        "replacement": "&&",
        "code": "default_exp = _outgoing[0];"
      },
      {
        "line": 38,
        "operator": "and",
        "replacement": "&&",
        "code": "return;"
      },
      {
        "line": 64,
        "operator": "not",
        "replacement": "!",
        "code": "if (i == _outgoing.size() - 1) {"
      }
    ]
  },
  "atomspace/opencog/atoms/core/Context.cc": {
    "alt_operators": [
      {
        "line": 59,
        "operator": "or",
        "replacement": "||",
        "code": "// Update quotation"
      },
      {
        "line": 60,
        "operator": "and",
        "replacement": "&&",
        "code": "quotation.update(t);"
      },
      {
        "line": 61,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 61,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 67,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 68,
        "operator": "and",
        "replacement": "&&",
        "code": "bool Context::is_unquoted() const"
      },
      {
        "line": 69,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 69,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 76,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 76,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 78,
        "operator": "not",
        "replacement": "!",
        "code": "bool Context::is_free_variable(const Handle& h) const"
      },
      {
        "line": 78,
        "operator": "or",
        "replacement": "||",
        "code": "bool Context::is_free_variable(const Handle& h) const"
      },
      {
        "line": 79,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 79,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 90,
        "operator": "not",
        "replacement": "!",
        "code": "and // only look at scope variables if both care about it"
      }
    ]
  },
  "atomspace/opencog/atoms/core/DeleteLink.cc": {
    "alt_operators": [
      {
        "line": 53,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atoms/core/FindUtils.cc": {
    "alt_operators": [
      {
        "line": 48,
        "operator": "or",
        "replacement": "||",
        "code": "std::inserter(_target_types, _target_types.end()));"
      },
      {
        "line": 84,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 109,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 125,
        "operator": "not",
        "replacement": "!",
        "code": "bool is_unquoted_in_tree(const Handle& tree, const Handle& atom)"
      },
      {
        "line": 139,
        "operator": "not",
        "replacement": "!",
        "code": "quotation.update(tree->get_type());"
      },
      {
        "line": 159,
        "operator": "not",
        "replacement": "!",
        "code": "return result;"
      },
      {
        "line": 178,
        "operator": "not",
        "replacement": "!",
        "code": "return true;"
      },
      {
        "line": 196,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 275,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 340,
        "operator": "and",
        "replacement": "&&",
        "code": "for (const Handle& n: atoms)"
      },
      {
        "line": 345,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 360,
        "operator": "and",
        "replacement": "&&",
        "code": "return false;"
      },
      {
        "line": 365,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 381,
        "operator": "and",
        "replacement": "&&",
        "code": "bool contains_exposed_atomtype(const Handle& clause, Type atom_type,"
      },
      {
        "line": 386,
        "operator": "not",
        "replacement": "!",
        "code": "Type clause_type = clause->get_type();"
      },
      {
        "line": 400,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 400,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 460,
        "operator": "not",
        "replacement": "!",
        "code": "// Base cases"
      }
    ]
  },
  "atomspace/opencog/atoms/core/FreeVariables.cc": {
    "alt_operators": [
      {
        "line": 133,
        "operator": "not",
        "replacement": "!",
        "code": "bool is_equivalent(const Handle& rh, const Handle& lh) const;"
      },
      {
        "line": 157,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 204,
        "operator": "not",
        "replacement": "!",
        "code": "HandleSeq VarScraper::sorted_free_variables_outgoing(bool ordered,"
      },
      {
        "line": 221,
        "operator": "not",
        "replacement": "!",
        "code": "// Only retain variables that are ! in res"
      },
      {
        "line": 235,
        "operator": "or",
        "replacement": "||",
        "code": "const HandleSeq& outgoing, const Context& ctx) const"
      },
      {
        "line": 285,
        "operator": "not",
        "replacement": "!",
        "code": "const HandleSeq& rhs) const"
      }
    ]
  },
  "atomspace/opencog/atoms/core/FunctionLink.cc": {
    "alt_operators": [
      {
        "line": 41,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atoms/core/GrantLink.cc": {
    "alt_operators": [
      {
        "line": 42,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 67,
        "operator": "not",
        "replacement": "!",
        "code": "if (this == &other) return true;"
      }
    ]
  },
  "atomspace/opencog/atoms/core/NumberNode.cc": {
    "alt_operators": [
      {
        "line": 53,
        "operator": "and",
        "replacement": "&&",
        "code": "if (0 == str.find(\"#(\")) in = 2;      // is it a scheme vector?"
      },
      {
        "line": 56,
        "operator": "or",
        "replacement": "||",
        "code": "// First condition in the loop will trim str."
      },
      {
        "line": 58,
        "operator": "or",
        "replacement": "||",
        "code": "and (pos = str.find_first_of(\", \\t\", in)) != std::string::npos)"
      },
      {
        "line": 67,
        "operator": "or",
        "replacement": "||",
        "code": "in = pos + 1;"
      },
      {
        "line": 69,
        "operator": "or",
        "replacement": "||",
        "code": "if (in != std::string::npos)"
      },
      {
        "line": 222,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 225,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 233,
        "operator": "and",
        "replacement": "&&",
        "code": "if (1 == nn->size())"
      },
      {
        "line": 258,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 261,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 269,
        "operator": "and",
        "replacement": "&&",
        "code": "if (1 == nn->size())"
      },
      {
        "line": 293,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 296,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 299,
        "operator": "and",
        "replacement": "&&",
        "code": "return times(NumberNodeCast(vi), NumberNodeCast(vj));"
      },
      {
        "line": 318,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 321,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 324,
        "operator": "and",
        "replacement": "&&",
        "code": "return divide(NumberNodeCast(vi), NumberNodeCast(vj));"
      }
    ]
  },
  "atomspace/opencog/atoms/core/PrenexLink.cc": {
    "alt_operators": [
      {
        "line": 64,
        "operator": "not",
        "replacement": "!",
        "code": "/// If the result of beta reduction is an expression with bound"
      },
      {
        "line": 64,
        "operator": "and",
        "replacement": "&&",
        "code": "/// If the result of beta reduction is an expression with bound"
      },
      {
        "line": 162,
        "operator": "not",
        "replacement": "!",
        "code": "//"
      },
      {
        "line": 211,
        "operator": "or",
        "replacement": "||",
        "code": "// between old and new variables when alpha-conversion is used."
      },
      {
        "line": 278,
        "operator": "or",
        "replacement": "||",
        "code": "// alpha-convert, instead."
      }
    ]
  },
  "atomspace/opencog/atoms/core/PresentLink.cc": {
    "alt_operators": [
      {
        "line": 40,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/core/PutLink.cc": {
    "alt_operators": [
      {
        "line": 56,
        "operator": "not",
        "replacement": "!",
        "code": "///          <atom 1>"
      },
      {
        "line": 60,
        "operator": "and",
        "replacement": "&&",
        "code": "/// The below is a handy-dandy easy-to-use form. When it is reduced,"
      },
      {
        "line": 105,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 113,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 141,
        "operator": "not",
        "replacement": "!",
        "code": "LambdaLinkPtr lam(LambdaLinkCast(_arguments));"
      },
      {
        "line": 142,
        "operator": "and",
        "replacement": "&&",
        "code": "Handle body = lam->get_body();"
      },
      {
        "line": 143,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 144,
        "operator": "not",
        "replacement": "!",
        "code": "// The body might ! exist, if there's an unmantched"
      },
      {
        "line": 144,
        "operator": "and",
        "replacement": "&&",
        "code": "// The body might ! exist, if there's an unmantched"
      },
      {
        "line": 165,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 173,
        "operator": "not",
        "replacement": "!",
        "code": "if (_variables.is_type(body))"
      },
      {
        "line": 194,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 216,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 226,
        "operator": "not",
        "replacement": "!",
        "code": "if (1 < sz)"
      },
      {
        "line": 303,
        "operator": "not",
        "replacement": "!",
        "code": "* variables, it performs alpha conversion instead of beta reduction."
      },
      {
        "line": 351,
        "operator": "and",
        "replacement": "&&",
        "code": "// Most arguments can be executed (should be executed) before"
      },
      {
        "line": 486,
        "operator": "not",
        "replacement": "!",
        "code": "for (const Handle& h : args->getOutgoingSet())"
      },
      {
        "line": 503,
        "operator": "or",
        "replacement": "||",
        "code": "// below."
      },
      {
        "line": 511,
        "operator": "not",
        "replacement": "!",
        "code": "return reddy(subs, oset);"
      }
    ]
  },
  "atomspace/opencog/atoms/core/Quotation.cc": {
    "alt_operators": [
      {
        "line": 35,
        "operator": "or",
        "replacement": "||",
        "code": "int Quotation::level() const"
      },
      {
        "line": 40,
        "operator": "not",
        "replacement": "!",
        "code": "bool Quotation::is_locally_quoted() const"
      },
      {
        "line": 40,
        "operator": "and",
        "replacement": "&&",
        "code": "bool Quotation::is_locally_quoted() const"
      },
      {
        "line": 40,
        "operator": "or",
        "replacement": "||",
        "code": "bool Quotation::is_locally_quoted() const"
      },
      {
        "line": 41,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 41,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 46,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 47,
        "operator": "not",
        "replacement": "!",
        "code": "return _quotation_level != 0 or is_locally_quoted();"
      },
      {
        "line": 50,
        "operator": "and",
        "replacement": "&&",
        "code": "bool Quotation::is_unquoted() const"
      },
      {
        "line": 81,
        "operator": "not",
        "replacement": "!",
        "code": "// in theory. In practice, QuoteUTest builds a weird unbalanced"
      },
      {
        "line": 81,
        "operator": "and",
        "replacement": "&&",
        "code": "// in theory. In practice, QuoteUTest builds a weird unbalanced"
      },
      {
        "line": 112,
        "operator": "or",
        "replacement": "||",
        "code": "for (const Handle& ho: h->getOutgoingSet())"
      },
      {
        "line": 113,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 119,
        "operator": "and",
        "replacement": "&&",
        "code": "bool unquoted_below(const Handle& h)"
      }
    ]
  },
  "atomspace/opencog/atoms/core/RandomChoice.cc": {
    "alt_operators": [
      {
        "line": 106,
        "operator": "and",
        "replacement": "&&",
        "code": "///           ..."
      },
      {
        "line": 106,
        "operator": "or",
        "replacement": "||",
        "code": "///           ..."
      },
      {
        "line": 145,
        "operator": "and",
        "replacement": "&&",
        "code": "if (nullptr == nn) // goto uniform;"
      }
    ]
  },
  "atomspace/opencog/atoms/core/Replacement.cc": {
    "alt_operators": [
      {
        "line": 59,
        "operator": "not",
        "replacement": "!",
        "code": "/// 2. The semantics of scoping (alpha-conversion) is honored, so that"
      },
      {
        "line": 71,
        "operator": "and",
        "replacement": "&&",
        "code": "// If we are not in a quote context, && `term` is a variable,"
      },
      {
        "line": 141,
        "operator": "not",
        "replacement": "!",
        "code": "else"
      },
      {
        "line": 154,
        "operator": "not",
        "replacement": "!",
        "code": "//"
      },
      {
        "line": 210,
        "operator": "and",
        "replacement": "&&",
        "code": "const IndexMap& index_map)"
      }
    ]
  },
  "atomspace/opencog/atoms/core/RewriteLink.cc": {
    "alt_operators": [
      {
        "line": 70,
        "operator": "or",
        "replacement": "||",
        "code": "Handle nvardecl = substitute_vardecl(vm);"
      },
      {
        "line": 85,
        "operator": "or",
        "replacement": "||",
        "code": "// Its illegal to create a PutLink that is not in the"
      },
      {
        "line": 162,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 235,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 235,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 285,
        "operator": "not",
        "replacement": "!",
        "code": "// \tneedless_quotation = false;"
      },
      {
        "line": 286,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 287,
        "operator": "not",
        "replacement": "!",
        "code": "return h;"
      },
      {
        "line": 288,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 331,
        "operator": "or",
        "replacement": "||",
        "code": "// needless_quotation to true before the recursion."
      },
      {
        "line": 363,
        "operator": "not",
        "replacement": "!",
        "code": "needless_quotation = true;"
      },
      {
        "line": 363,
        "operator": "and",
        "replacement": "&&",
        "code": "needless_quotation = true;"
      },
      {
        "line": 376,
        "operator": "and",
        "replacement": "&&",
        "code": "(is_logical_connector(t) &&"
      },
      {
        "line": 440,
        "operator": "or",
        "replacement": "||",
        "code": "Handle vardecl = unquote->getOutgoingAtom(0);"
      }
    ]
  },
  "atomspace/opencog/atoms/core/ScopeLink.cc": {
    "alt_operators": [
      {
        "line": 49,
        "operator": "not",
        "replacement": "!",
        "code": "ScopeLink::ScopeLink(const Handle& vars, const Handle& body)"
      },
      {
        "line": 101,
        "operator": "and",
        "replacement": "&&",
        "code": "if (0 == sz)"
      },
      {
        "line": 104,
        "operator": "or",
        "replacement": "||",
        "code": "to_short_string().c_str());"
      },
      {
        "line": 251,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 359,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 359,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 381,
        "operator": "and",
        "replacement": "&&",
        "code": "/// scoped links.  The algorithm here is almost identical to that"
      },
      {
        "line": 434,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "atomspace/opencog/atoms/core/StateLink.cc": {
    "alt_operators": [
      {
        "line": 62,
        "operator": "not",
        "replacement": "!",
        "code": "/**"
      },
      {
        "line": 85,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 103,
        "operator": "not",
        "replacement": "!",
        "code": "bool swapped = false;"
      }
    ]
  },
  "atomspace/opencog/atoms/core/TimeLink.cc": {
    "posix_headers": [
      {
        "line": 29,
        "header": "sys/time.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <sys/time.h>"
      }
    ]
  },
  "atomspace/opencog/atoms/core/TypeChoice.cc": {
    "alt_operators": [
      {
        "line": 31,
        "operator": "and",
        "replacement": "&&",
        "code": "#include <opencog/atoms/core/TypeNode.h>"
      },
      {
        "line": 34,
        "operator": "or",
        "replacement": "||",
        "code": "#include \"TypeChoice.h\""
      },
      {
        "line": 57,
        "operator": "not",
        "replacement": "!",
        "code": "_simple_typeset.insert({NOTYPE});"
      },
      {
        "line": 73,
        "operator": "not",
        "replacement": "!",
        "code": "_is_untyped = true;"
      },
      {
        "line": 150,
        "operator": "and",
        "replacement": "&&",
        "code": "return GlobInterval{lb, ub};"
      },
      {
        "line": 152,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 163,
        "operator": "and",
        "replacement": "&&",
        "code": "*                 PredicateNode \"foobar\""
      },
      {
        "line": 172,
        "operator": "or",
        "replacement": "||",
        "code": "void TypeChoice::analyze(Handle anontype)"
      },
      {
        "line": 175,
        "operator": "and",
        "replacement": "&&",
        "code": "Type t = anontype->get_type();"
      },
      {
        "line": 255,
        "operator": "and",
        "replacement": "&&",
        "code": "return;"
      },
      {
        "line": 274,
        "operator": "or",
        "replacement": "||",
        "code": "bool TypeChoice::is_empty(const GlobInterval& glob)"
      },
      {
        "line": 288,
        "operator": "or",
        "replacement": "||",
        "code": "/// For backwards compatibility, (TypeChoice (Type 'Atom)) is also"
      },
      {
        "line": 296,
        "operator": "or",
        "replacement": "||",
        "code": "/// Return true if the type is a plain-old conventional type:"
      },
      {
        "line": 304,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 304,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 318,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 319,
        "operator": "not",
        "replacement": "!",
        "code": "return n >= _glob_interval.first;"
      },
      {
        "line": 323,
        "operator": "not",
        "replacement": "!",
        "code": "/// interval restriction."
      }
    ]
  },
  "atomspace/opencog/atoms/core/TypeIntersectionLink.cc": {
    "alt_operators": [
      {
        "line": 36,
        "operator": "not",
        "replacement": "!",
        "code": "* s1 and s2 must be sorted"
      },
      {
        "line": 55,
        "operator": "or",
        "replacement": "||",
        "code": "bool touched = false;"
      },
      {
        "line": 82,
        "operator": "or",
        "replacement": "||",
        "code": "const auto lb = std::max(lhs.first, rhs.first);"
      },
      {
        "line": 97,
        "operator": "and",
        "replacement": "&&",
        "code": "*             Number 3"
      },
      {
        "line": 106,
        "operator": "or",
        "replacement": "||",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/core/TypeUtils.cc": {
    "alt_operators": [
      {
        "line": 42,
        "operator": "or",
        "replacement": "||",
        "code": "* Type checker.  Returns true if `val` is of type `spec`."
      },
      {
        "line": 73,
        "operator": "not",
        "replacement": "!",
        "code": "Type deeptype = TypeNodeCast(deep)->get_kind();"
      },
      {
        "line": 99,
        "operator": "not",
        "replacement": "!",
        "code": "// If it is a link, then both must be same link type."
      },
      {
        "line": 99,
        "operator": "and",
        "replacement": "&&",
        "code": "// If it is a link, then both must be same link type."
      },
      {
        "line": 103,
        "operator": "not",
        "replacement": "!",
        "code": "if (deep->is_unordered_link())"
      },
      {
        "line": 103,
        "operator": "and",
        "replacement": "&&",
        "code": "if (deep->is_unordered_link())"
      },
      {
        "line": 105,
        "operator": "not",
        "replacement": "!",
        "code": "\"Not implemented! TODO XXX FIXME\");"
      },
      {
        "line": 105,
        "operator": "and",
        "replacement": "&&",
        "code": "\"Not implemented! TODO XXX FIXME\");"
      },
      {
        "line": 105,
        "operator": "or",
        "replacement": "||",
        "code": "\"Not implemented! TODO XXX FIXME\");"
      },
      {
        "line": 125,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 133,
        "operator": "not",
        "replacement": "!",
        "code": "off = 1;"
      },
      {
        "line": 185,
        "operator": "not",
        "replacement": "!",
        "code": "ltype = left->get_type();"
      },
      {
        "line": 249,
        "operator": "not",
        "replacement": "!",
        "code": "// (or a value, partly handled that above already, for"
      },
      {
        "line": 267,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 267,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 281,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 311,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 329,
        "operator": "and",
        "replacement": "&&",
        "code": "return filter_vardecl(vardecl, HandleSeq{body});"
      },
      {
        "line": 333,
        "operator": "or",
        "replacement": "||",
        "code": "// conceptually. The difference is trim() cuts down the vardecl"
      },
      {
        "line": 339,
        "operator": "and",
        "replacement": "&&",
        "code": "if (not vardecl)"
      },
      {
        "line": 344,
        "operator": "and",
        "replacement": "&&",
        "code": "Type t = vardecl->get_type();"
      },
      {
        "line": 365,
        "operator": "not",
        "replacement": "!",
        "code": "for (const Handle& v : vardecl->getOutgoingSet())"
      }
    ]
  },
  "atomspace/opencog/atoms/core/TypedVariableLink.cc": {
    "alt_operators": [
      {
        "line": 31,
        "operator": "not",
        "replacement": "!",
        "code": "void TypedVariableLink::init()"
      },
      {
        "line": 35,
        "operator": "and",
        "replacement": "&&",
        "code": "throw SyntaxException(TRACE_INFO,"
      },
      {
        "line": 131,
        "operator": "not",
        "replacement": "!",
        "code": "return false;"
      }
    ]
  },
  "atomspace/opencog/atoms/core/UniqueLink.cc": {
    "alt_operators": [
      {
        "line": 97,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atoms/core/Variables.cc": {
    "alt_operators": [
      {
        "line": 74,
        "operator": "or",
        "replacement": "||",
        "code": "\"Expecting TypedVariableLink, got %s\","
      },
      {
        "line": 83,
        "operator": "or",
        "replacement": "||",
        "code": "varseq.emplace_back(varname);"
      },
      {
        "line": 109,
        "operator": "or",
        "replacement": "||",
        "code": "// XXX FIXME URE calls us with broken handle!!"
      },
      {
        "line": 157,
        "operator": "and",
        "replacement": "&&",
        "code": "varseq.emplace_back(h);"
      },
      {
        "line": 158,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 158,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 158,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 164,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 225,
        "operator": "not",
        "replacement": "!",
        "code": "bool Variables::is_type(const Handle& h) const"
      },
      {
        "line": 248,
        "operator": "or",
        "replacement": "||",
        "code": "return tit->second->is_type(val);"
      },
      {
        "line": 258,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 298,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 332,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 383,
        "operator": "or",
        "replacement": "||",
        "code": "*       VariableNode $a"
      },
      {
        "line": 412,
        "operator": "not",
        "replacement": "!",
        "code": "*"
      },
      {
        "line": 440,
        "operator": "not",
        "replacement": "!",
        "code": "// if that argument is never actually used.  Fixing this requires a"
      },
      {
        "line": 460,
        "operator": "not",
        "replacement": "!",
        "code": "/* ================================================================= */"
      },
      {
        "line": 468,
        "operator": "not",
        "replacement": "!",
        "code": "*/"
      },
      {
        "line": 483,
        "operator": "or",
        "replacement": "||",
        "code": "// If either this || the other are ordered then the result is ordered"
      }
    ]
  },
  "atomspace/opencog/atoms/execution/EvaluationLink.cc": {
    "alt_operators": [
      {
        "line": 35,
        "operator": "not",
        "replacement": "!",
        "code": "#include <opencog/atoms/parallel/ThreadJoinLink.h>"
      },
      {
        "line": 270,
        "operator": "and",
        "replacement": "&&",
        "code": "static bool identical(const Handle& h)"
      },
      {
        "line": 303,
        "operator": "not",
        "replacement": "!",
        "code": "/// Check for alpha equivalence. If the link contains no free"
      },
      {
        "line": 324,
        "operator": "not",
        "replacement": "!",
        "code": "// Not strictly equal. Are they alpha convertible?"
      },
      {
        "line": 325,
        "operator": "not",
        "replacement": "!",
        "code": "Variables v0, v1;"
      },
      {
        "line": 348,
        "operator": "not",
        "replacement": "!",
        "code": "ValuePtr v1(exec_or_eval(as, oset[1], as, silent));"
      },
      {
        "line": 349,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 359,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 385,
        "operator": "or",
        "replacement": "||",
        "code": "if (h0 == h1) {found = true; break;}"
      },
      {
        "line": 414,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 485,
        "operator": "or",
        "replacement": "||",
        "code": "/// now, this is straight-forward and it works."
      },
      {
        "line": 511,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 519,
        "operator": "not",
        "replacement": "!",
        "code": "// we ignore the TV on it. We are doing this for the side-effects,"
      },
      {
        "line": 548,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 656,
        "operator": "not",
        "replacement": "!",
        "code": "if (! vp->is_atom())"
      },
      {
        "line": 792,
        "operator": "and",
        "replacement": "&&",
        "code": "///     EvaluationLink"
      },
      {
        "line": 823,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 914,
        "operator": "not",
        "replacement": "!",
        "code": "return EvaluationLink::do_eval_scratch(as,"
      },
      {
        "line": 934,
        "operator": "not",
        "replacement": "!",
        "code": "const Handle& evelnk,"
      },
      {
        "line": 939,
        "operator": "not",
        "replacement": "!",
        "code": "bool fail;"
      }
    ]
  },
  "atomspace/opencog/atoms/execution/ExecutionOutputLink.cc": {
    "alt_operators": [
      {
        "line": 82,
        "operator": "not",
        "replacement": "!",
        "code": "///         GroundedSchemaNode \"lang: func_name\""
      },
      {
        "line": 87,
        "operator": "not",
        "replacement": "!",
        "code": "/// The \"lang:\" should be \"scm:\" for scheme, \"py:\" for python, or"
      },
      {
        "line": 90,
        "operator": "not",
        "replacement": "!",
        "code": "///"
      },
      {
        "line": 95,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 112,
        "operator": "not",
        "replacement": "!",
        "code": "while (res->is_executable())"
      },
      {
        "line": 133,
        "operator": "not",
        "replacement": "!",
        "code": "elt = HandleCast(vp);"
      },
      {
        "line": 142,
        "operator": "not",
        "replacement": "!",
        "code": "///"
      },
      {
        "line": 192,
        "operator": "or",
        "replacement": "||",
        "code": "sn->to_string().c_str());"
      },
      {
        "line": 213,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atoms/execution/Force.cc": {
    "alt_operators": [
      {
        "line": 38,
        "operator": "and",
        "replacement": "&&",
        "code": "///"
      },
      {
        "line": 59,
        "operator": "not",
        "replacement": "!",
        "code": "args = as->add_atom(args);"
      }
    ]
  },
  "atomspace/opencog/atoms/execution/Instantiator.cc": {
    "alt_operators": [
      {
        "line": 70,
        "operator": "and",
        "replacement": "&&",
        "code": "/// result of execution/evaluation changed something."
      },
      {
        "line": 142,
        "operator": "or",
        "replacement": "||",
        "code": "Variables vars(flp->get_variables());"
      },
      {
        "line": 159,
        "operator": "not",
        "replacement": "!",
        "code": "// PLNRulesUTest::test_implication_scope_to_implication"
      },
      {
        "line": 219,
        "operator": "or",
        "replacement": "||",
        "code": "/// This can be contrasted with `beta_reduce()` up above, which performs"
      },
      {
        "line": 231,
        "operator": "or",
        "replacement": "||",
        "code": "Type t = expr->get_type();"
      },
      {
        "line": 259,
        "operator": "and",
        "replacement": "&&",
        "code": "nexp->copyValues(expr);"
      },
      {
        "line": 264,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 264,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 326,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 348,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 370,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 481,
        "operator": "and",
        "replacement": "&&",
        "code": "// of expr being a FunctionLink - this can return a Value, which"
      },
      {
        "line": 506,
        "operator": "not",
        "replacement": "!",
        "code": "for (const Handle& gg : hg->getOutgoingSet())"
      },
      {
        "line": 541,
        "operator": "and",
        "replacement": "&&",
        "code": "return eolh->execute(_as, silent);"
      },
      {
        "line": 569,
        "operator": "not",
        "replacement": "!",
        "code": "if (! reduced->is_atom()) return reduced;"
      },
      {
        "line": 569,
        "operator": "and",
        "replacement": "&&",
        "code": "if (! reduced->is_atom()) return reduced;"
      },
      {
        "line": 600,
        "operator": "and",
        "replacement": "&&",
        "code": "// Check for crazy cross-atomspace woes"
      },
      {
        "line": 610,
        "operator": "and",
        "replacement": "&&",
        "code": "Handle dex = DefineLink::get_definition(expr);"
      }
    ]
  },
  "atomspace/opencog/atoms/flow/CollectionOfLink.cc": {
    "alt_operators": [
      {
        "line": 52,
        "operator": "not",
        "replacement": "!",
        "code": "void CollectionOfLink::check_typespec(void)"
      },
      {
        "line": 59,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 59,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 88,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 117,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atoms/flow/ConcatenateLink.cc": {
    "alt_operators": [
      {
        "line": 34,
        "operator": "not",
        "replacement": "!",
        "code": "if (! nameserver().isA(t, CONCATENATE_LINK))"
      },
      {
        "line": 46,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 57,
        "operator": "not",
        "replacement": "!",
        "code": "for (const Handle& oli : base->getOutgoingSet())"
      }
    ]
  },
  "atomspace/opencog/atoms/flow/FilterLink.cc": {
    "alt_operators": [
      {
        "line": 95,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 129,
        "operator": "and",
        "replacement": "&&",
        "code": "/// std::vector<Handle> or std::vector<Value>"
      },
      {
        "line": 155,
        "operator": "and",
        "replacement": "&&",
        "code": "// Globs at the end are handled differently than globs"
      },
      {
        "line": 168,
        "operator": "not",
        "replacement": "!",
        "code": "if (! tc) return false;"
      },
      {
        "line": 204,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 208,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 273,
        "operator": "and",
        "replacement": "&&",
        "code": "///"
      },
      {
        "line": 283,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 289,
        "operator": "and",
        "replacement": "&&",
        "code": "// not enough experience to say. There is, however, a unit test to"
      },
      {
        "line": 315,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 318,
        "operator": "not",
        "replacement": "!",
        "code": "if (! _mvars->is_type(termpat, vgnd)) return false;"
      },
      {
        "line": 369,
        "operator": "not",
        "replacement": "!",
        "code": "valmap.swap(vcopy);"
      },
      {
        "line": 402,
        "operator": "not",
        "replacement": "!",
        "code": "size_t off = 0;"
      },
      {
        "line": 417,
        "operator": "not",
        "replacement": "!",
        "code": "// If the sizes are mismatched, should we do a fuzzy match?"
      },
      {
        "line": 426,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 464,
        "operator": "not",
        "replacement": "!",
        "code": "make_lnkv, tsz, off);"
      },
      {
        "line": 472,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 561,
        "operator": "not",
        "replacement": "!",
        "code": "if (red->is_atom())"
      },
      {
        "line": 561,
        "operator": "and",
        "replacement": "&&",
        "code": "if (red->is_atom())"
      },
      {
        "line": 565,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 592,
        "operator": "not",
        "replacement": "!",
        "code": "HandleSeq hseq;"
      },
      {
        "line": 618,
        "operator": "or",
        "replacement": "||",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/flow/FormulaPredicateLink.cc": {
    "alt_operators": [
      {
        "line": 32,
        "operator": "not",
        "replacement": "!",
        "code": "using namespace opencog;"
      },
      {
        "line": 38,
        "operator": "and",
        "replacement": "&&",
        "code": "/// not typed, && there are *two* bodies, each body returning one"
      },
      {
        "line": 98,
        "operator": "not",
        "replacement": "!",
        "code": "if (h->is_type(VARIABLE_LIST)) continue;"
      },
      {
        "line": 107,
        "operator": "not",
        "replacement": "!",
        "code": "// In case the user wanted to wrap everything in a"
      },
      {
        "line": 152,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "atomspace/opencog/atoms/flow/IncomingOfLink.cc": {
    "alt_operators": [
      {
        "line": 49,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/flow/NumberOfLink.cc": {
    "alt_operators": [
      {
        "line": 34,
        "operator": "not",
        "replacement": "!",
        "code": "if (! nameserver().isA(t, NUMBER_OF_LINK))"
      }
    ]
  },
  "atomspace/opencog/atoms/flow/PromiseLink.cc": {
    "alt_operators": [
      {
        "line": 64,
        "operator": "not",
        "replacement": "!",
        "code": "_future_type = NOTYPE;"
      },
      {
        "line": 64,
        "operator": "or",
        "replacement": "||",
        "code": "_future_type = NOTYPE;"
      },
      {
        "line": 69,
        "operator": "and",
        "replacement": "&&",
        "code": "if (TYPE_NODE == h->get_type())"
      },
      {
        "line": 73,
        "operator": "not",
        "replacement": "!",
        "code": "_future_type = tnp->get_kind();"
      }
    ]
  },
  "atomspace/opencog/atoms/flow/SplitLink.cc": {
    "alt_operators": [
      {
        "line": 37,
        "operator": "not",
        "replacement": "!",
        "code": "const std::string& tname = nameserver().getTypeName(t);"
      },
      {
        "line": 81,
        "operator": "not",
        "replacement": "!",
        "code": "return createLinkValue(_out_type, std::move(hsq));"
      }
    ]
  },
  "atomspace/opencog/atoms/flow/StreamValueOfLink.cc": {
    "alt_operators": [
      {
        "line": 76,
        "operator": "not",
        "replacement": "!",
        "code": "// Test for Truth before Float, since Truth isa Float"
      }
    ]
  },
  "atomspace/opencog/atoms/flow/StringOfLink.cc": {
    "alt_operators": [
      {
        "line": 39,
        "operator": "not",
        "replacement": "!",
        "code": "throw InvalidParamException(TRACE_INFO,"
      },
      {
        "line": 47,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 63,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 74,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 74,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/flow/TruthValueOfLink.cc": {
    "alt_operators": [
      {
        "line": 31,
        "operator": "not",
        "replacement": "!",
        "code": "// Why am I writing this again, from scratch?"
      },
      {
        "line": 56,
        "operator": "not",
        "replacement": "!",
        "code": "\"Expecting an TruthValueOfLink, got %s\", tname.c_str());"
      },
      {
        "line": 76,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 90,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 110,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 124,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 144,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atoms/foreign/ForeignAST.cc": {
    "alt_operators": [
      {
        "line": 45,
        "operator": "not",
        "replacement": "!",
        "code": "throw InvalidParamException(TRACE_INFO,"
      }
    ]
  },
  "atomspace/opencog/atoms/grounded/DLPython.cc": {
    "posix_headers": [
      {
        "line": 29,
        "header": "dlfcn.h",
        "windows_equiv": [
          "Windows.h (LoadLibrary)"
        ],
        "code": "#include <dlfcn.h>"
      }
    ]
  },
  "atomspace/opencog/atoms/grounded/DLScheme.cc": {
    "posix_headers": [
      {
        "line": 29,
        "header": "dlfcn.h",
        "windows_equiv": [
          "Windows.h (LoadLibrary)"
        ],
        "code": "#include <dlfcn.h>"
      }
    ]
  },
  "atomspace/opencog/atoms/grounded/GroundedPredicateNode.cc": {
    "alt_operators": [
      {
        "line": 116,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/grounded/LibraryManager.cc": {
    "posix_headers": [
      {
        "line": 29,
        "header": "dlfcn.h",
        "windows_equiv": [
          "Windows.h (LoadLibrary)"
        ],
        "code": "#include <dlfcn.h>"
      }
    ]
  },
  "atomspace/opencog/atoms/grounded/LibraryRunner.cc": {
    "alt_operators": [
      {
        "line": 46,
        "operator": "not",
        "replacement": "!",
        "code": "static void throwSyntaxEx(bool silent, const char* message...)"
      },
      {
        "line": 81,
        "operator": "not",
        "replacement": "!",
        "code": "// Execute the function"
      }
    ]
  },
  "atomspace/opencog/atoms/grounded/PythonRunner.cc": {
    "alt_operators": [
      {
        "line": 33,
        "operator": "not",
        "replacement": "!",
        "code": "#error \"Error: The Makefiles or CMakefiles are misconfigured, and failed to detect Cython correctly.\""
      },
      {
        "line": 55,
        "operator": "not",
        "replacement": "!",
        "code": "throw SyntaxException(TRACE_INFO,"
      }
    ]
  },
  "atomspace/opencog/atoms/join/JoinLink.cc": {
    "alt_operators": [
      {
        "line": 32,
        "operator": "not",
        "replacement": "!",
        "code": "#include <opencog/atomspace/AtomSpace.h>"
      },
      {
        "line": 78,
        "operator": "and",
        "replacement": "&&",
        "code": "for (size_t i=0; i<_outgoing.size(); i++)"
      },
      {
        "line": 79,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 80,
        "operator": "and",
        "replacement": "&&",
        "code": "const Handle& clause(_outgoing[i]);"
      },
      {
        "line": 108,
        "operator": "not",
        "replacement": "!",
        "code": "/// setup_meet() -- create a search that can find the all of"
      },
      {
        "line": 108,
        "operator": "and",
        "replacement": "&&",
        "code": "/// setup_meet() -- create a search that can find the all of"
      },
      {
        "line": 111,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 267,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 458,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 496,
        "operator": "not",
        "replacement": "!",
        "code": "for (const auto& pare: base_map)"
      },
      {
        "line": 666,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atoms/parallel/DefinedProcedureNode.cc": {
    "alt_operators": [
      {
        "line": 62,
        "operator": "not",
        "replacement": "!",
        "code": "// strictly speaking \"that's a bug\". However, practical usage of"
      },
      {
        "line": 65,
        "operator": "not",
        "replacement": "!",
        "code": "//"
      }
    ]
  },
  "atomspace/opencog/atoms/parallel/ExecuteThreadedLink.cc": {
    "alt_operators": [
      {
        "line": 100,
        "operator": "not",
        "replacement": "!",
        "code": "ExecuteThreadedLink::~ExecuteThreadedLink()"
      },
      {
        "line": 108,
        "operator": "and",
        "replacement": "&&",
        "code": "if (_joiner.joinable())"
      },
      {
        "line": 130,
        "operator": "and",
        "replacement": "&&",
        "code": "pap = as->add_atom(HandleCast(pap));"
      },
      {
        "line": 133,
        "operator": "not",
        "replacement": "!",
        "code": "catch (const std::exception& ex)"
      }
    ]
  },
  "atomspace/opencog/atoms/parallel/PureExecLink.cc": {
    "alt_operators": [
      {
        "line": 54,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/parallel/SleepLink.cc": {
    "posix_headers": [
      {
        "line": 42,
        "header": "sys/time.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <sys/time.h>"
      },
      {
        "line": 45,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 36,
        "operator": "not",
        "replacement": "!",
        "code": "#ifdef _WIN32"
      },
      {
        "line": 48,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/pattern/PatternJit.cc": {
    "alt_operators": [
      {
        "line": 36,
        "operator": "not",
        "replacement": "!",
        "code": "* present, or may have changed since the pattern was initially created."
      }
    ]
  },
  "atomspace/opencog/atoms/pattern/PatternLink.cc": {
    "alt_operators": [
      {
        "line": 48,
        "operator": "or",
        "replacement": "||",
        "code": "locate_defines(_pat.always);"
      },
      {
        "line": 182,
        "operator": "and",
        "replacement": "&&",
        "code": "_virtual.clear();"
      },
      {
        "line": 182,
        "operator": "or",
        "replacement": "||",
        "code": "_virtual.clear();"
      },
      {
        "line": 214,
        "operator": "and",
        "replacement": "&&",
        "code": "void PatternLink::init(void)"
      },
      {
        "line": 352,
        "operator": "not",
        "replacement": "!",
        "code": "_variables.varseq.clear();"
      },
      {
        "line": 362,
        "operator": "not",
        "replacement": "!",
        "code": "for (const Handle& h : compo)"
      },
      {
        "line": 422,
        "operator": "not",
        "replacement": "!",
        "code": "setup_components();"
      },
      {
        "line": 458,
        "operator": "not",
        "replacement": "!",
        "code": "void PatternLink::record_mandatory(const PatternTermPtr& term)"
      },
      {
        "line": 458,
        "operator": "and",
        "replacement": "&&",
        "code": "void PatternLink::record_mandatory(const PatternTermPtr& term)"
      },
      {
        "line": 459,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 474,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 474,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 492,
        "operator": "not",
        "replacement": "!",
        "code": "// PresentLinks. They are ! mandatory, since they exist only in"
      },
      {
        "line": 512,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 513,
        "operator": "and",
        "replacement": "&&",
        "code": "else if (not is_constant(_variables.varset, ph))"
      },
      {
        "line": 533,
        "operator": "and",
        "replacement": "&&",
        "code": "if ((not reverse && ABSENT_LINK == typ) or"
      },
      {
        "line": 538,
        "operator": "not",
        "replacement": "!",
        "code": "// be absent\"?  Or is it \"if any of A && B are absent, then ..\""
      },
      {
        "line": 538,
        "operator": "and",
        "replacement": "&&",
        "code": "// be absent\"?  Or is it \"if any of A && B are absent, then ..\""
      },
      {
        "line": 556,
        "operator": "not",
        "replacement": "!",
        "code": "\"NotLink-ChoiceLink is ! supported yet!\");"
      },
      {
        "line": 556,
        "operator": "and",
        "replacement": "&&",
        "code": "\"NotLink-ChoiceLink is ! supported yet!\");"
      },
      {
        "line": 596,
        "operator": "not",
        "replacement": "!",
        "code": "for (const Handle& ah: h->getOutgoingSet())"
      },
      {
        "line": 596,
        "operator": "and",
        "replacement": "&&",
        "code": "for (const Handle& ah: h->getOutgoingSet())"
      },
      {
        "line": 630,
        "operator": "not",
        "replacement": "!",
        "code": "/// literal, groundable clauses. `record_literal` does this."
      },
      {
        "line": 679,
        "operator": "not",
        "replacement": "!",
        "code": "/// of the code below, but ! all, and work with a LinearTermMixin"
      },
      {
        "line": 680,
        "operator": "not",
        "replacement": "!",
        "code": "/// callback class to complete the matching process."
      },
      {
        "line": 681,
        "operator": "not",
        "replacement": "!",
        "code": "void PatternLink::unbundle_clauses(const Handle& hbody)"
      },
      {
        "line": 682,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 686,
        "operator": "not",
        "replacement": "!",
        "code": "if (AND_LINK == hbody->get_type())"
      },
      {
        "line": 708,
        "operator": "not",
        "replacement": "!",
        "code": "_fixed.emplace_back(clause);"
      },
      {
        "line": 709,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 713,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 740,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 740,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 741,
        "operator": "not",
        "replacement": "!",
        "code": "void PatternLink::locate_defines(const PatternTermSeq& clauses)"
      },
      {
        "line": 741,
        "operator": "and",
        "replacement": "&&",
        "code": "void PatternLink::locate_defines(const PatternTermSeq& clauses)"
      },
      {
        "line": 794,
        "operator": "not",
        "replacement": "!",
        "code": "/* ================================================================= */"
      },
      {
        "line": 849,
        "operator": "and",
        "replacement": "&&",
        "code": "///"
      },
      {
        "line": 849,
        "operator": "or",
        "replacement": "||",
        "code": "///"
      },
      {
        "line": 883,
        "operator": "not",
        "replacement": "!",
        "code": "if (0 < nv)"
      },
      {
        "line": 915,
        "operator": "or",
        "replacement": "||",
        "code": "for (const PatternTermPtr& man : _pat.pmandatory)"
      },
      {
        "line": 917,
        "operator": "or",
        "replacement": "||",
        "code": "HandleSet vman = get_free_variables(man->getQuote());"
      },
      {
        "line": 918,
        "operator": "or",
        "replacement": "||",
        "code": "if (vman.end() != vman.find(v))"
      },
      {
        "line": 926,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 938,
        "operator": "not",
        "replacement": "!",
        "code": "/// links that have exactly one variable in them, and at least one"
      },
      {
        "line": 954,
        "operator": "not",
        "replacement": "!",
        "code": "// ! even called for any of these cases."
      },
      {
        "line": 956,
        "operator": "not",
        "replacement": "!",
        "code": "if (CHOICE_LINK == t or ALWAYS_LINK == t) return false;"
      },
      {
        "line": 957,
        "operator": "not",
        "replacement": "!",
        "code": "if (GROUP_LINK == t) return false;"
      },
      {
        "line": 961,
        "operator": "not",
        "replacement": "!",
        "code": "PatternTermPtr parnt = ptm->getParent();"
      },
      {
        "line": 971,
        "operator": "or",
        "replacement": "||",
        "code": "if (EVALUATION_LINK == t)"
      },
      {
        "line": 1015,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 1016,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 1023,
        "operator": "not",
        "replacement": "!",
        "code": "/// (evaluatable) so we know that in general it cannot be found in"
      },
      {
        "line": 1109,
        "operator": "or",
        "replacement": "||",
        "code": "for (const Handle& var: var->getOutgoingSet())"
      },
      {
        "line": 1138,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 1139,
        "operator": "and",
        "replacement": "&&",
        "code": "const auto& it = vunion.find(v);"
      },
      {
        "line": 1140,
        "operator": "not",
        "replacement": "!",
        "code": "if (vunion.end() == it)"
      },
      {
        "line": 1140,
        "operator": "and",
        "replacement": "&&",
        "code": "if (vunion.end() == it)"
      },
      {
        "line": 1146,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 1153,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 1186,
        "operator": "or",
        "replacement": "||",
        "code": "Type t = h->get_type();"
      },
      {
        "line": 1187,
        "operator": "not",
        "replacement": "!",
        "code": "if ((VARIABLE_NODE == t or GLOB_NODE == t)"
      },
      {
        "line": 1187,
        "operator": "and",
        "replacement": "&&",
        "code": "if ((VARIABLE_NODE == t or GLOB_NODE == t)"
      },
      {
        "line": 1196,
        "operator": "not",
        "replacement": "!",
        "code": "ptm->addGlobbyVar();"
      },
      {
        "line": 1215,
        "operator": "not",
        "replacement": "!",
        "code": "size_t cnt = 0;"
      },
      {
        "line": 1215,
        "operator": "or",
        "replacement": "||",
        "code": "size_t cnt = 0;"
      },
      {
        "line": 1237,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 1238,
        "operator": "or",
        "replacement": "||",
        "code": "// If its an AndLink, make sure that all of the children are"
      },
      {
        "line": 1239,
        "operator": "not",
        "replacement": "!",
        "code": "// evaluatable. The problem is .. users insert AndLinks into"
      },
      {
        "line": 1239,
        "operator": "and",
        "replacement": "&&",
        "code": "// evaluatable. The problem is .. users insert AndLinks into"
      },
      {
        "line": 1240,
        "operator": "not",
        "replacement": "!",
        "code": "// random places..."
      },
      {
        "line": 1240,
        "operator": "and",
        "replacement": "&&",
        "code": "// random places..."
      },
      {
        "line": 1244,
        "operator": "and",
        "replacement": "&&",
        "code": "for (const Handle& ho : h->getOutgoingSet())"
      },
      {
        "line": 1285,
        "operator": "and",
        "replacement": "&&",
        "code": "// particularly well-thought out. Might be buggy..."
      },
      {
        "line": 1289,
        "operator": "or",
        "replacement": "||",
        "code": "chk_const = chk_const and not ptm->isQuoted();"
      },
      {
        "line": 1290,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 1290,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 1292,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 1300,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 1345,
        "operator": "not",
        "replacement": "!",
        "code": "// random places..."
      }
    ]
  },
  "atomspace/opencog/atoms/pattern/PatternTerm.cc": {
    "alt_operators": [
      {
        "line": 141,
        "operator": "not",
        "replacement": "!",
        "code": "* Equality operator.  Both the content must match, and the path"
      },
      {
        "line": 173,
        "operator": "not",
        "replacement": "!",
        "code": "if (isQuoted()) return;"
      },
      {
        "line": 198,
        "operator": "not",
        "replacement": "!",
        "code": "void PatternTerm::addGlobbyVar()"
      },
      {
        "line": 297,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 321,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 328,
        "operator": "not",
        "replacement": "!",
        "code": "if (isQuoted()) return;"
      },
      {
        "line": 334,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 369,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 410,
        "operator": "not",
        "replacement": "!",
        "code": "if (_is_literal) str += \"L: \";"
      }
    ]
  },
  "atomspace/opencog/atoms/pattern/PatternTerm.h": {
    "alt_operators": [
      {
        "line": 163,
        "operator": "and",
        "replacement": "&&",
        "code": "// present in the pattern. All of the sub-terms are present, or"
      },
      {
        "line": 264,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 316,
        "operator": "not",
        "replacement": "!",
        "code": "const opencog::Handle& lHandle = lhs->getHandle();"
      }
    ]
  },
  "atomspace/opencog/atoms/pattern/PatternUtils.cc": {
    "alt_operators": [
      {
        "line": 31,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 35,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 36,
        "operator": "or",
        "replacement": "||",
        "code": "bool can_evaluate(const Handle& clause)"
      },
      {
        "line": 37,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 45,
        "operator": "not",
        "replacement": "!",
        "code": "// over a PredicateNode."
      },
      {
        "line": 46,
        "operator": "not",
        "replacement": "!",
        "code": "(nameserver().isA(ct, EVALUATABLE_LINK)"
      },
      {
        "line": 46,
        "operator": "and",
        "replacement": "&&",
        "code": "(nameserver().isA(ct, EVALUATABLE_LINK)"
      },
      {
        "line": 61,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 62,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 109,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/pattern/QueryLink.cc": {
    "alt_operators": [
      {
        "line": 66,
        "operator": "and",
        "replacement": "&&",
        "code": "const Handle& rewrite)"
      },
      {
        "line": 116,
        "operator": "and",
        "replacement": "&&",
        "code": "* get naive users into trouble, but there are legit uses, not just"
      },
      {
        "line": 117,
        "operator": "not",
        "replacement": "!",
        "code": "* in the URE, for doing disconnected searches."
      },
      {
        "line": 117,
        "operator": "and",
        "replacement": "&&",
        "code": "* in the URE, for doing disconnected searches."
      }
    ]
  },
  "atomspace/opencog/atoms/reduct/AccumulateLink.cc": {
    "alt_operators": [
      {
        "line": 93,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atoms/reduct/ArithmeticLink.cc": {
    "alt_operators": [
      {
        "line": 73,
        "operator": "not",
        "replacement": "!",
        "code": "///"
      },
      {
        "line": 73,
        "operator": "or",
        "replacement": "||",
        "code": "///"
      },
      {
        "line": 97,
        "operator": "not",
        "replacement": "!",
        "code": "return alp->reorder();"
      }
    ]
  },
  "atomspace/opencog/atoms/reduct/BoolOpLink.cc": {
    "alt_operators": [
      {
        "line": 36,
        "operator": "and",
        "replacement": "&&",
        "code": "if (BOOL_OR_LINK == get_type()) return createBoolValue(false);"
      },
      {
        "line": 39,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "atomspace/opencog/atoms/reduct/DivideLink.cc": {
    "alt_operators": [
      {
        "line": 52,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 63,
        "operator": "and",
        "replacement": "&&",
        "code": "catch (const SilentException& ex)"
      },
      {
        "line": 67,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 84,
        "operator": "and",
        "replacement": "&&",
        "code": "Handle hquot(createNumberNode(divide(vi, multiplicand)));"
      },
      {
        "line": 108,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      }
    ]
  },
  "atomspace/opencog/atoms/reduct/MinusLink.cc": {
    "alt_operators": [
      {
        "line": 49,
        "operator": "and",
        "replacement": "&&",
        "code": "Type vitype = vi->get_type();"
      },
      {
        "line": 57,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 68,
        "operator": "and",
        "replacement": "&&",
        "code": "catch (const SilentException& ex)"
      },
      {
        "line": 85,
        "operator": "and",
        "replacement": "&&",
        "code": "Handle hdiff(createNumberNode(minus(vi, addend)));"
      },
      {
        "line": 109,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      }
    ]
  },
  "atomspace/opencog/atoms/reduct/NumericFunctionLink.cc": {
    "alt_operators": [
      {
        "line": 32,
        "operator": "and",
        "replacement": "&&",
        "code": "using namespace opencog;"
      },
      {
        "line": 34,
        "operator": "and",
        "replacement": "&&",
        "code": "NumericFunctionLink::NumericFunctionLink(const HandleSeq&& oset, Type t)"
      },
      {
        "line": 37,
        "operator": "and",
        "replacement": "&&",
        "code": "init();"
      },
      {
        "line": 40,
        "operator": "and",
        "replacement": "&&",
        "code": "void NumericFunctionLink::init(void)"
      },
      {
        "line": 42,
        "operator": "and",
        "replacement": "&&",
        "code": "Type t = get_type();"
      },
      {
        "line": 44,
        "operator": "and",
        "replacement": "&&",
        "code": "throw InvalidParamException(TRACE_INFO,"
      },
      {
        "line": 46,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 48,
        "operator": "and",
        "replacement": "&&",
        "code": "throw InvalidParamException(TRACE_INFO, \"Expecting an NumericFunctionLink\");"
      },
      {
        "line": 65,
        "operator": "not",
        "replacement": "!",
        "code": "throw InvalidParamException(TRACE_INFO, \"CosineLink expects one argument\");"
      },
      {
        "line": 65,
        "operator": "and",
        "replacement": "&&",
        "code": "throw InvalidParamException(TRACE_INFO, \"CosineLink expects one argument\");"
      },
      {
        "line": 96,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 135,
        "operator": "or",
        "replacement": "||",
        "code": "/// In this last case, the result of reduction is returned"
      },
      {
        "line": 136,
        "operator": "or",
        "replacement": "||",
        "code": "/// in `reduction`"
      },
      {
        "line": 163,
        "operator": "and",
        "replacement": "&&",
        "code": "std::vector<double> funvec;"
      },
      {
        "line": 276,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      }
    ]
  },
  "atomspace/opencog/atoms/reduct/PlusLink.cc": {
    "alt_operators": [
      {
        "line": 32,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 55,
        "operator": "and",
        "replacement": "&&",
        "code": "Type vitype = vi->get_type();"
      },
      {
        "line": 63,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 117,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 131,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 212,
        "operator": "and",
        "replacement": "&&",
        "code": "if (NUMBER_NODE == vitype && nameserver().isA(vjtype, FLOAT_VALUE))"
      }
    ]
  },
  "atomspace/opencog/atoms/reduct/TimesLink.cc": {
    "alt_operators": [
      {
        "line": 102,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 113,
        "operator": "and",
        "replacement": "&&",
        "code": "catch (const SilentException& ex)"
      },
      {
        "line": 115,
        "operator": "and",
        "replacement": "&&",
        "code": "// If we are here, they were not simple numbers."
      },
      {
        "line": 124,
        "operator": "and",
        "replacement": "&&",
        "code": "if (nameserver().isA(vjtype, NUMBER_NODE))"
      },
      {
        "line": 144,
        "operator": "and",
        "replacement": "&&",
        "code": "return createTimesLink(hquot, dividend);"
      }
    ]
  },
  "atomspace/opencog/atoms/rule/VardeclOfLink.cc": {
    "alt_operators": [
      {
        "line": 53,
        "operator": "not",
        "replacement": "!",
        "code": "if (! ho->is_type(PRENEX_LINK))"
      }
    ]
  },
  "atomspace/opencog/atoms/truthvalue/CountTruthValue.cc": {
    "alt_operators": [
      {
        "line": 114,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 115,
        "operator": "not",
        "replacement": "!",
        "code": "if (2 >= idx)"
      },
      {
        "line": 116,
        "operator": "not",
        "replacement": "!",
        "code": "new_vect[idx] += count;"
      }
    ]
  },
  "atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc": {
    "alt_operators": [
      {
        "line": 48,
        "operator": "and",
        "replacement": "&&",
        "code": ": SimpleTruthValue(0, 0), _formula(std::move(seq))"
      },
      {
        "line": 60,
        "operator": "not",
        "replacement": "!",
        "code": "{}"
      },
      {
        "line": 61,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 71,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 94,
        "operator": "not",
        "replacement": "!",
        "code": "\"Formula %d needs to be executable; got %s\","
      },
      {
        "line": 112,
        "operator": "not",
        "replacement": "!",
        "code": "if (fut->is_executable())"
      }
    ]
  },
  "atomspace/opencog/atoms/truthvalue/SimpleTruthValue.cc": {
    "alt_operators": [
      {
        "line": 49,
        "operator": "not",
        "replacement": "!",
        "code": "_value.resize(2);"
      },
      {
        "line": 92,
        "operator": "not",
        "replacement": "!",
        "code": "count_t SimpleTruthValue::get_count() const"
      },
      {
        "line": 98,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 101,
        "operator": "not",
        "replacement": "!",
        "code": "return _value[CONFIDENCE];"
      }
    ]
  },
  "atomspace/opencog/atoms/truthvalue/TruthValue.cc": {
    "alt_operators": [
      {
        "line": 117,
        "operator": "or",
        "replacement": "||",
        "code": "dtv = FALSE_TV();"
      }
    ]
  },
  "atomspace/opencog/atoms/value/FloatValue.cc": {
    "alt_operators": [
      {
        "line": 46,
        "operator": "not",
        "replacement": "!",
        "code": "ValuePtr FloatValue::incrementCount(size_t idx, double count) const"
      }
    ]
  },
  "atomspace/opencog/atoms/value/FormulaStream.cc": {
    "alt_operators": [
      {
        "line": 54,
        "operator": "and",
        "replacement": "&&",
        "code": "FloatValue(FORMULA_STREAM)"
      },
      {
        "line": 61,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 62,
        "operator": "not",
        "replacement": "!",
        "code": "if (0 == _formula.size())"
      },
      {
        "line": 71,
        "operator": "not",
        "replacement": "!",
        "code": "void FormulaStream::init(void)"
      },
      {
        "line": 109,
        "operator": "not",
        "replacement": "!",
        "code": "if (! vp->is_type(FLOAT_VALUE))"
      },
      {
        "line": 144,
        "operator": "not",
        "replacement": "!",
        "code": "std::string rv = indent + \"(\" + nameserver().getTypeName(_type);"
      }
    ]
  },
  "atomspace/opencog/atoms/value/FutureStream.cc": {
    "alt_operators": [
      {
        "line": 54,
        "operator": "and",
        "replacement": "&&",
        "code": "LinkValue(FUTURE_STREAM)"
      },
      {
        "line": 60,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 61,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/atoms/value/LinkValue.cc": {
    "alt_operators": [
      {
        "line": 57,
        "operator": "not",
        "replacement": "!",
        "code": "hs.insert(HandleCast(v));"
      }
    ]
  },
  "atomspace/opencog/atoms/value/QueueValue.cc": {
    "alt_operators": [
      {
        "line": 41,
        "operator": "and",
        "replacement": "&&",
        "code": "// then they need to re-open."
      },
      {
        "line": 62,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 75,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 145,
        "operator": "not",
        "replacement": "!",
        "code": "if (conq::is_closed())"
      },
      {
        "line": 146,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atoms/value/UnisetValue.cc": {
    "alt_operators": [
      {
        "line": 41,
        "operator": "and",
        "replacement": "&&",
        "code": "// then they need to re-open."
      },
      {
        "line": 62,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 75,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 145,
        "operator": "not",
        "replacement": "!",
        "code": "if (conset::is_closed())"
      },
      {
        "line": 146,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atoms/value/Value.h": {
    "alt_operators": [
      {
        "line": 48,
        "operator": "not",
        "replacement": "!",
        "code": ": public std::enable_shared_from_this<Value>"
      },
      {
        "line": 68,
        "operator": "not",
        "replacement": "!",
        "code": "/** Basic predicate */"
      }
    ]
  },
  "atomspace/opencog/atomspace/AtomSpace.cc": {
    "alt_operators": [
      {
        "line": 88,
        "operator": "not",
        "replacement": "!",
        "code": "if( false)"
      },
      {
        "line": 88,
        "operator": "and",
        "replacement": "&&",
        "code": "if( false)"
      },
      {
        "line": 89,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 89,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 247,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 247,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 448,
        "operator": "or",
        "replacement": "||",
        "code": "/* other hard-to-debug bugs in the user's code ...                */ \\"
      },
      {
        "line": 449,
        "operator": "not",
        "replacement": "!",
        "code": "/* if (nullptr == has)                                            */ \\"
      }
    ]
  },
  "atomspace/opencog/atomspace/AtomSpace.h": {
    "alt_operators": [
      {
        "line": 306,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atomspace/AtomTable.cc": {
    "alt_operators": [
      {
        "line": 87,
        "operator": "not",
        "replacement": "!",
        "code": "Frame(ATOM_SPACE),"
      },
      {
        "line": 107,
        "operator": "not",
        "replacement": "!",
        "code": "_read_only(false),"
      },
      {
        "line": 107,
        "operator": "or",
        "replacement": "||",
        "code": "_read_only(false),"
      },
      {
        "line": 118,
        "operator": "not",
        "replacement": "!",
        "code": "\"AtomSpace - bases must be AtomSpaces!\");"
      },
      {
        "line": 156,
        "operator": "and",
        "replacement": "&&",
        "code": "_outgoing.clear();"
      },
      {
        "line": 174,
        "operator": "and",
        "replacement": "&&",
        "code": "///"
      },
      {
        "line": 239,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 250,
        "operator": "not",
        "replacement": "!",
        "code": "Handle AtomSpace::check(const Handle& orig, bool force)"
      },
      {
        "line": 258,
        "operator": "not",
        "replacement": "!",
        "code": "hc->setPresent();"
      },
      {
        "line": 284,
        "operator": "not",
        "replacement": "!",
        "code": "// have supplied an explicit outgoing set, with explicit atomspace"
      },
      {
        "line": 284,
        "operator": "and",
        "replacement": "&&",
        "code": "// have supplied an explicit outgoing set, with explicit atomspace"
      },
      {
        "line": 331,
        "operator": "not",
        "replacement": "!",
        "code": "need_copy = true;"
      },
      {
        "line": 331,
        "operator": "and",
        "replacement": "&&",
        "code": "need_copy = true;"
      },
      {
        "line": 331,
        "operator": "or",
        "replacement": "||",
        "code": "need_copy = true;"
      },
      {
        "line": 332,
        "operator": "not",
        "replacement": "!",
        "code": "else"
      },
      {
        "line": 354,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 452,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 456,
        "operator": "not",
        "replacement": "!",
        "code": "bool AtomSpace::extract_atom(const Handle& h, bool recursive)"
      },
      {
        "line": 458,
        "operator": "and",
        "replacement": "&&",
        "code": "if (nullptr == h) return false;"
      },
      {
        "line": 470,
        "operator": "not",
        "replacement": "!",
        "code": "// into those)."
      },
      {
        "line": 498,
        "operator": "not",
        "replacement": "!",
        "code": "// appears in incoming sets. Do nothing for the ordinary case."
      },
      {
        "line": 552,
        "operator": "not",
        "replacement": "!",
        "code": "const Handle& hide(add(handle, true, true, true));"
      },
      {
        "line": 580,
        "operator": "not",
        "replacement": "!",
        "code": "//"
      },
      {
        "line": 580,
        "operator": "and",
        "replacement": "&&",
        "code": "//"
      },
      {
        "line": 659,
        "operator": "not",
        "replacement": "!",
        "code": "typeIndex.get_handles_by_type(rawseq, type, subclass);"
      },
      {
        "line": 659,
        "operator": "and",
        "replacement": "&&",
        "code": "typeIndex.get_handles_by_type(rawseq, type, subclass);"
      },
      {
        "line": 702,
        "operator": "not",
        "replacement": "!",
        "code": "hset.insert(StateLinkCast(h)->get_link(cas));"
      },
      {
        "line": 702,
        "operator": "and",
        "replacement": "&&",
        "code": "hset.insert(StateLinkCast(h)->get_link(cas));"
      },
      {
        "line": 727,
        "operator": "not",
        "replacement": "!",
        "code": "base->shadow_by_type(hset, type, subclass, parent, cas);"
      },
      {
        "line": 727,
        "operator": "and",
        "replacement": "&&",
        "code": "base->shadow_by_type(hset, type, subclass, parent, cas);"
      }
    ]
  },
  "atomspace/opencog/atomspace/Frame.cc": {
    "alt_operators": [
      {
        "line": 63,
        "operator": "not",
        "replacement": "!",
        "code": "if (nullptr == h->getAtomSpace())"
      },
      {
        "line": 74,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/atomspace/TypeIndex.cc": {
    "alt_operators": [
      {
        "line": 81,
        "operator": "not",
        "replacement": "!",
        "code": "// using the AtomSpace again, while we do final cleanup. BTW,"
      },
      {
        "line": 81,
        "operator": "and",
        "replacement": "&&",
        "code": "// using the AtomSpace again, while we do final cleanup. BTW,"
      },
      {
        "line": 107,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 112,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 130,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 144,
        "operator": "not",
        "replacement": "!",
        "code": "// Same as above, except using an unordered set."
      },
      {
        "line": 168,
        "operator": "not",
        "replacement": "!",
        "code": "if (! _nameserver.isA(t, type)) continue;"
      },
      {
        "line": 168,
        "operator": "and",
        "replacement": "&&",
        "code": "if (! _nameserver.isA(t, type)) continue;"
      },
      {
        "line": 197,
        "operator": "not",
        "replacement": "!",
        "code": "// allocations and copies whenever the allocated size is exceeded."
      },
      {
        "line": 202,
        "operator": "not",
        "replacement": "!",
        "code": "int start = get_bucket_start(type);"
      }
    ]
  },
  "atomspace/opencog/atomspace/TypeIndex.h": {
    "alt_operators": [
      {
        "line": 58,
        "operator": "not",
        "replacement": "!",
        "code": "#if USE_FOLLY"
      },
      {
        "line": 179,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 184,
        "operator": "and",
        "replacement": "&&",
        "code": "size_t cnt = 0;"
      }
    ]
  },
  "atomspace/opencog/cython/PythonEval.cc": {
    "posix_headers": [
      {
        "line": 43,
        "header": "dlfcn.h",
        "windows_equiv": [
          "Windows.h (LoadLibrary)"
        ],
        "code": "#include <dlfcn.h>"
      },
      {
        "line": 46,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 289,
        "operator": "not",
        "replacement": "!",
        "code": "if (nullptr == q) break;"
      },
      {
        "line": 502,
        "operator": "not",
        "replacement": "!",
        "code": "_pySysPath = PySys_GetObject((char*)\"path\");"
      },
      {
        "line": 708,
        "operator": "not",
        "replacement": "!",
        "code": "this->import_module(file, pyFromList);"
      },
      {
        "line": 1052,
        "operator": "not",
        "replacement": "!",
        "code": "PyGILState_STATE gstate = PyGILState_Ensure();"
      },
      {
        "line": 1117,
        "operator": "not",
        "replacement": "!",
        "code": "} SCOPE_GUARD_END;"
      },
      {
        "line": 1166,
        "operator": "not",
        "replacement": "!",
        "code": "if (pyTraceback)"
      },
      {
        "line": 1246,
        "operator": "or",
        "replacement": "||",
        "code": "// PyString_AsString to print it gives \"None\" in all situations."
      },
      {
        "line": 1279,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 1300,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 1371,
        "operator": "not",
        "replacement": "!",
        "code": "if (std::string::npos != cmnt)"
      }
    ]
  },
  "atomspace/opencog/guile/SchemeEval.cc": {
    "posix_headers": [
      {
        "line": 35,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 293,
        "operator": "not",
        "replacement": "!",
        "code": "asm volatile(\"\": : :\"memory\");"
      },
      {
        "line": 297,
        "operator": "not",
        "replacement": "!",
        "code": "while (true) { pause(); }"
      },
      {
        "line": 587,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 674,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 687,
        "operator": "not",
        "replacement": "!",
        "code": "/// Set the _rc member in an pseudo-atomic fashion."
      },
      {
        "line": 788,
        "operator": "and",
        "replacement": "&&",
        "code": "rv += \"\\n\";"
      },
      {
        "line": 805,
        "operator": "not",
        "replacement": "!",
        "code": "* collection, etc. to work correctly!"
      },
      {
        "line": 805,
        "operator": "and",
        "replacement": "&&",
        "code": "* collection, etc. to work correctly!"
      }
    ]
  },
  "atomspace/opencog/guile/SchemePrimitive.cc": {
    "alt_operators": [
      {
        "line": 155,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/guile/SchemeSmob.cc": {
    "posix_headers": [
      {
        "line": 34,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 42,
        "operator": "not",
        "replacement": "!",
        "code": "#include \"SchemeSmob.h\""
      },
      {
        "line": 51,
        "operator": "and",
        "replacement": "&&",
        "code": "* ephemeral (garbage-collected), including the Handles.  Note that"
      },
      {
        "line": 52,
        "operator": "and",
        "replacement": "&&",
        "code": "* atoms in the atomspace have a concrete existence outside of the"
      },
      {
        "line": 104,
        "operator": "not",
        "replacement": "!",
        "code": "done_with_init = true;"
      },
      {
        "line": 105,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 148,
        "operator": "or",
        "replacement": "||",
        "code": "scm_t_bits tb = SCM_SMOB_FLAGS(b);"
      },
      {
        "line": 168,
        "operator": "not",
        "replacement": "!",
        "code": "case COG_EXTEND:"
      },
      {
        "line": 181,
        "operator": "and",
        "replacement": "&&",
        "code": "ValuePtr* bv = SCM_SMOB_VALUE_PTR_LOC(b);"
      }
    ]
  },
  "atomspace/opencog/guile/SchemeSmobAS.cc": {
    "alt_operators": [
      {
        "line": 84,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/guile/SchemeSmobAtom.cc": {
    "alt_operators": [
      {
        "line": 33,
        "operator": "not",
        "replacement": "!",
        "code": "#include <opencog/atoms/core/NumberNode.h>"
      },
      {
        "line": 33,
        "operator": "or",
        "replacement": "||",
        "code": "#include <opencog/atoms/core/NumberNode.h>"
      }
    ]
  },
  "atomspace/opencog/guile/SchemeSmobLogger.cc": {
    "alt_operators": [
      {
        "line": 39,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/guile/SchemeSmobNew.cc": {
    "alt_operators": [
      {
        "line": 33,
        "operator": "not",
        "replacement": "!",
        "code": "return misc_to_string(node);"
      },
      {
        "line": 82,
        "operator": "not",
        "replacement": "!",
        "code": "return protom_to_scm(AtomCast(h));"
      },
      {
        "line": 106,
        "operator": "not",
        "replacement": "!",
        "code": "return nullptr;"
      },
      {
        "line": 117,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 175,
        "operator": "not",
        "replacement": "!",
        "code": "if (vleft == vright) return SCM_BOOL_T;"
      },
      {
        "line": 282,
        "operator": "not",
        "replacement": "!",
        "code": "* Check that the argument is a boolean constant, else throw errors."
      },
      {
        "line": 294,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 313,
        "operator": "and",
        "replacement": "&&",
        "code": "* Return the string, in C."
      },
      {
        "line": 314,
        "operator": "and",
        "replacement": "&&",
        "code": "*/"
      },
      {
        "line": 336,
        "operator": "not",
        "replacement": "!",
        "code": "// Perhaps we are done. Phew."
      },
      {
        "line": 362,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 405,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 419,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 601,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 618,
        "operator": "not",
        "replacement": "!",
        "code": "// Create the AST. Unwrap singleton strings, so they"
      },
      {
        "line": 623,
        "operator": "not",
        "replacement": "!",
        "code": "(scm_is_string(SCM_CAR(sexpr)) or"
      },
      {
        "line": 644,
        "operator": "not",
        "replacement": "!",
        "code": "*/"
      }
    ]
  },
  "atomspace/opencog/guile/SchemeSmobPrint.cc": {
    "alt_operators": [
      {
        "line": 54,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/guile/SchemeSmobValue.cc": {
    "alt_operators": [
      {
        "line": 44,
        "operator": "not",
        "replacement": "!",
        "code": "SCM SchemeSmob::from_type (const ValuePtr& vp)"
      },
      {
        "line": 62,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 73,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 80,
        "operator": "not",
        "replacement": "!",
        "code": "SchemeSmob::verify_bool_list (SCM svalue_list, const char * subrname, int pos)"
      },
      {
        "line": 104,
        "operator": "and",
        "replacement": "&&",
        "code": "bool v;"
      },
      {
        "line": 115,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 122,
        "operator": "not",
        "replacement": "!",
        "code": "*/"
      },
      {
        "line": 138,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 149,
        "operator": "and",
        "replacement": "&&",
        "code": "valist.emplace_back(v);"
      },
      {
        "line": 156,
        "operator": "not",
        "replacement": "!",
        "code": "/**"
      },
      {
        "line": 182,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 194,
        "operator": "and",
        "replacement": "&&",
        "code": "if (pa) valist.emplace_back(pa);"
      },
      {
        "line": 215,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 215,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 220,
        "operator": "not",
        "replacement": "!",
        "code": "SCM sl = svalue_list;"
      },
      {
        "line": 220,
        "operator": "and",
        "replacement": "&&",
        "code": "SCM sl = svalue_list;"
      },
      {
        "line": 225,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 230,
        "operator": "not",
        "replacement": "!",
        "code": "if (! scm_is_null(svalue)) {"
      },
      {
        "line": 271,
        "operator": "or",
        "replacement": "||",
        "code": "bool zero_args = scm_is_null(first_arg);"
      },
      {
        "line": 279,
        "operator": "or",
        "replacement": "||",
        "code": "scm_is_pair(svalue_list) and"
      },
      {
        "line": 287,
        "operator": "or",
        "replacement": "||",
        "code": "scm_is_string(first_arg))"
      },
      {
        "line": 297,
        "operator": "and",
        "replacement": "&&",
        "code": "if (vp && vp->is_atom())"
      },
      {
        "line": 302,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 302,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 307,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 429,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 517,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "atomspace/opencog/guile/modules/ExecSCM.cc": {
    "alt_operators": [
      {
        "line": 46,
        "operator": "and",
        "replacement": "&&",
        "code": "ValuePtr pap(inst.execute(h));"
      }
    ]
  },
  "atomspace/opencog/guile/modules/LoggerSCM.cc": {
    "alt_operators": [
      {
        "line": 182,
        "operator": "and",
        "replacement": "&&",
        "code": "void LoggerSCM::do_logger_info(Logger* lg, const std::string& msg)"
      }
    ]
  },
  "atomspace/opencog/ocaml/CamlWrap.cc": {
    "alt_operators": [
      {
        "line": 107,
        "operator": "and",
        "replacement": "&&",
        "code": "p = vatomlist;"
      },
      {
        "line": 158,
        "operator": "and",
        "replacement": "&&",
        "code": "/// Return a string holding the s-expression for the atom."
      },
      {
        "line": 210,
        "operator": "not",
        "replacement": "!",
        "code": "/// Pretty-print the atom in OCaml format; that is, return what it"
      },
      {
        "line": 211,
        "operator": "not",
        "replacement": "!",
        "code": "/// should look like, when considered in OCaml atomese. e.g."
      },
      {
        "line": 212,
        "operator": "not",
        "replacement": "!",
        "code": "/// `(Concept \"bar\")` is printed as `concept \"bar\"`."
      },
      {
        "line": 213,
        "operator": "not",
        "replacement": "!",
        "code": "std::string oc_to_caml_str(const Handle& h, const std::string& indent)"
      },
      {
        "line": 214,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 215,
        "operator": "not",
        "replacement": "!",
        "code": "if (h == nullptr)"
      },
      {
        "line": 216,
        "operator": "not",
        "replacement": "!",
        "code": "return indent + \"null\";"
      },
      {
        "line": 217,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 230,
        "operator": "and",
        "replacement": "&&",
        "code": "// Chop off the trailing _link .. unless its a reserved word."
      }
    ]
  },
  "atomspace/opencog/query/InitiateSearchMixin.cc": {
    "alt_operators": [
      {
        "line": 106,
        "operator": "and",
        "replacement": "&&",
        "code": "// size_t& depth will be set to the depth of the thinnest constant found."
      },
      {
        "line": 135,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 150,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 150,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 191,
        "operator": "and",
        "replacement": "&&",
        "code": "if (CHOICE_LINK != t) sbr = ptm;"
      },
      {
        "line": 191,
        "operator": "or",
        "replacement": "||",
        "code": "if (CHOICE_LINK != t) sbr = ptm;"
      },
      {
        "line": 221,
        "operator": "not",
        "replacement": "!",
        "code": "depth = deepest;"
      },
      {
        "line": 221,
        "operator": "and",
        "replacement": "&&",
        "code": "depth = deepest;"
      },
      {
        "line": 229,
        "operator": "and",
        "replacement": "&&",
        "code": "* Skip any/all evaluatable clauses, as these typically do not"
      },
      {
        "line": 230,
        "operator": "and",
        "replacement": "&&",
        "code": "* exist in the atomspace, anyway."
      },
      {
        "line": 230,
        "operator": "or",
        "replacement": "||",
        "code": "* exist in the atomspace, anyway."
      },
      {
        "line": 264,
        "operator": "not",
        "replacement": "!",
        "code": "starter_term = term;"
      },
      {
        "line": 264,
        "operator": "or",
        "replacement": "||",
        "code": "starter_term = term;"
      },
      {
        "line": 300,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 375,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 375,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 482,
        "operator": "not",
        "replacement": "!",
        "code": "* \"standard, canonical\" searches, then the pattern match should be"
      },
      {
        "line": 491,
        "operator": "not",
        "replacement": "!",
        "code": "*"
      },
      {
        "line": 552,
        "operator": "not",
        "replacement": "!",
        "code": "// start, which can happen if the clauses ... !?"
      },
      {
        "line": 553,
        "operator": "not",
        "replacement": "!",
        "code": "DO_LOG({logger().fine(\"Cannot use node-neighbor search, use deep-type search\");})"
      },
      {
        "line": 554,
        "operator": "not",
        "replacement": "!",
        "code": "if (setup_deep_type_search(clauses))"
      },
      {
        "line": 631,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 808,
        "operator": "and",
        "replacement": "&&",
        "code": "if (0 == dtypes.size()) continue;"
      },
      {
        "line": 816,
        "operator": "not",
        "replacement": "!",
        "code": "DO_LOG({LAZY_LOG_FINE"
      },
      {
        "line": 889,
        "operator": "not",
        "replacement": "!",
        "code": "_root = PatternTerm::UNDEFINED;"
      },
      {
        "line": 1075,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/query/NextSearchMixin.cc": {
    "alt_operators": [
      {
        "line": 71,
        "operator": "not",
        "replacement": "!",
        "code": "* clauses are grounded; thus these are saved for last.  It is always"
      },
      {
        "line": 274,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 274,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 274,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 275,
        "operator": "not",
        "replacement": "!",
        "code": "// We cannot use GlobNode's directly as joiners, because"
      },
      {
        "line": 275,
        "operator": "and",
        "replacement": "&&",
        "code": "// We cannot use GlobNode's directly as joiners, because"
      },
      {
        "line": 275,
        "operator": "or",
        "replacement": "||",
        "code": "// We cannot use GlobNode's directly as joiners, because"
      },
      {
        "line": 294,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 294,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 315,
        "operator": "not",
        "replacement": "!",
        "code": "std::size_t pursue_thickness = tckvar.first;"
      },
      {
        "line": 315,
        "operator": "or",
        "replacement": "||",
        "code": "std::size_t pursue_thickness = tckvar.first;"
      }
    ]
  },
  "atomspace/opencog/query/PatternMatchEngine.cc": {
    "alt_operators": [
      {
        "line": 91,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 133,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 154,
        "operator": "not",
        "replacement": "!",
        "code": "OC_ASSERT (hp->is_node(),"
      },
      {
        "line": 220,
        "operator": "not",
        "replacement": "!",
        "code": "depth ++;"
      },
      {
        "line": 232,
        "operator": "not",
        "replacement": "!",
        "code": "match = glob_compare(osp, osg);"
      },
      {
        "line": 241,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 399,
        "operator": "not",
        "replacement": "!",
        "code": "return cs->second;"
      },
      {
        "line": 409,
        "operator": "not",
        "replacement": "!",
        "code": "static int facto (int n) { return (n==1)? 1 : n * facto(n-1); };"
      },
      {
        "line": 409,
        "operator": "and",
        "replacement": "&&",
        "code": "static int facto (int n) { return (n==1)? 1 : n * facto(n-1); };"
      },
      {
        "line": 445,
        "operator": "and",
        "replacement": "&&",
        "code": "(the `have_more` boolean flag)."
      },
      {
        "line": 457,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 466,
        "operator": "not",
        "replacement": "!",
        "code": "take one step."
      },
      {
        "line": 466,
        "operator": "and",
        "replacement": "&&",
        "code": "take one step."
      },
      {
        "line": 471,
        "operator": "and",
        "replacement": "&&",
        "code": "It could be treated much as the above, with the understanding that"
      },
      {
        "line": 817,
        "operator": "not",
        "replacement": "!",
        "code": "bool match = true;"
      },
      {
        "line": 817,
        "operator": "and",
        "replacement": "&&",
        "code": "bool match = true;"
      },
      {
        "line": 825,
        "operator": "or",
        "replacement": "||",
        "code": "GlobPosStack glob_pos_stack;"
      },
      {
        "line": 882,
        "operator": "and",
        "replacement": "&&",
        "code": "_glob_state.erase(osp);"
      },
      {
        "line": 900,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 948,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 976,
        "operator": "and",
        "replacement": "&&",
        "code": "// search from a previous state)"
      },
      {
        "line": 983,
        "operator": "not",
        "replacement": "!",
        "code": "// On the other hand, if we failed to ground this glob"
      },
      {
        "line": 1087,
        "operator": "not",
        "replacement": "!",
        "code": "// Try again if this pair is ! a match."
      },
      {
        "line": 1089,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 1116,
        "operator": "and",
        "replacement": "&&",
        "code": "// inefficient for truly sparse searches. A (vastly) superior search"
      },
      {
        "line": 1180,
        "operator": "not",
        "replacement": "!",
        "code": "Type pty = osp[i]->getHandle()->get_type();"
      },
      {
        "line": 1193,
        "operator": "not",
        "replacement": "!",
        "code": "return false;"
      },
      {
        "line": 1239,
        "operator": "and",
        "replacement": "&&",
        "code": "logmsg(\"Grounded sparse rotor %d at %d\", it, ig);"
      },
      {
        "line": 1363,
        "operator": "not",
        "replacement": "!",
        "code": "solution_push();"
      },
      {
        "line": 1363,
        "operator": "and",
        "replacement": "&&",
        "code": "solution_push();"
      },
      {
        "line": 1376,
        "operator": "not",
        "replacement": "!",
        "code": "for (int j=0; j<szp; j++) solution_drop();"
      },
      {
        "line": 1376,
        "operator": "and",
        "replacement": "&&",
        "code": "for (int j=0; j<szp; j++) solution_drop();"
      },
      {
        "line": 1386,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 1386,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 1395,
        "operator": "and",
        "replacement": "&&",
        "code": "it --;"
      },
      {
        "line": 1408,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 1408,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 1420,
        "operator": "not",
        "replacement": "!",
        "code": "if (! match) return false;"
      },
      {
        "line": 1420,
        "operator": "or",
        "replacement": "||",
        "code": "if (! match) return false;"
      },
      {
        "line": 1464,
        "operator": "and",
        "replacement": "&&",
        "code": "*"
      },
      {
        "line": 1473,
        "operator": "and",
        "replacement": "&&",
        "code": "* && so quotes can be used to search for expressions containing"
      },
      {
        "line": 1552,
        "operator": "not",
        "replacement": "!",
        "code": "if (! match) return false;"
      },
      {
        "line": 1652,
        "operator": "not",
        "replacement": "!",
        "code": "//         ListLink"
      },
      {
        "line": 1795,
        "operator": "and",
        "replacement": "&&",
        "code": "for (size_t i = 0; i < sz; i++)"
      },
      {
        "line": 1976,
        "operator": "not",
        "replacement": "!",
        "code": "return true;"
      },
      {
        "line": 2114,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 2137,
        "operator": "not",
        "replacement": "!",
        "code": "\"Maybe this works but its ! tested!! Find out!\");"
      },
      {
        "line": 2173,
        "operator": "not",
        "replacement": "!",
        "code": "const PatternTermPtr& vterm = find_variable_term(subterm, var);"
      },
      {
        "line": 2255,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 2255,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 2281,
        "operator": "not",
        "replacement": "!",
        "code": "logmsg(\"!! explore_present success!\");"
      },
      {
        "line": 2304,
        "operator": "not",
        "replacement": "!",
        "code": "const PatternTermPtr& clause)"
      },
      {
        "line": 2338,
        "operator": "and",
        "replacement": "&&",
        "code": "/// Note that, in the \"normal\" case, a given term has only one, unique"
      },
      {
        "line": 2346,
        "operator": "not",
        "replacement": "!",
        "code": "///    clause."
      },
      {
        "line": 2348,
        "operator": "not",
        "replacement": "!",
        "code": "///    clause, all at different locations.  This is very rare, but"
      },
      {
        "line": 2401,
        "operator": "not",
        "replacement": "!",
        "code": "// Handle identical terms before evaluatables."
      },
      {
        "line": 2443,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 2474,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 2606,
        "operator": "not",
        "replacement": "!",
        "code": "if (! match) {"
      },
      {
        "line": 2690,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 2737,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 2737,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 2758,
        "operator": "or",
        "replacement": "||",
        "code": "// If the groundings need to be grouped together, pass that off to"
      },
      {
        "line": 2787,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 2792,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 2813,
        "operator": "not",
        "replacement": "!",
        "code": "_grouping.insert(grp);"
      },
      {
        "line": 2826,
        "operator": "not",
        "replacement": "!",
        "code": "size_t nitems = _var_ground_cache.size();"
      },
      {
        "line": 2920,
        "operator": "not",
        "replacement": "!",
        "code": "* to handle other situations as well, e.g. Bayesian formulas, etc.)"
      },
      {
        "line": 2939,
        "operator": "not",
        "replacement": "!",
        "code": "// We need to record failures for the AlwaysLink"
      },
      {
        "line": 2984,
        "operator": "not",
        "replacement": "!",
        "code": "* than two) must be identical. During search, two cases arise:"
      },
      {
        "line": 3058,
        "operator": "or",
        "replacement": "||",
        "code": "* from start to endpoint. Because multiple paths exist, the endpoint"
      },
      {
        "line": 3070,
        "operator": "and",
        "replacement": "&&",
        "code": "(Evaluation (Predicate \"bar\") (List (Concept \"y\") (Concept \"end-point\")))"
      },
      {
        "line": 3072,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 3091,
        "operator": "not",
        "replacement": "!",
        "code": "*"
      }
    ]
  },
  "atomspace/opencog/query/Recognizer.cc": {
    "alt_operators": [
      {
        "line": 155,
        "operator": "not",
        "replacement": "!",
        "code": "lpat->get_arity() == lsoln->get_arity())"
      },
      {
        "line": 168,
        "operator": "not",
        "replacement": "!",
        "code": "bool Recognizer::loose_match(const Handle& npat_h, const Handle& nsoln_h)"
      },
      {
        "line": 168,
        "operator": "or",
        "replacement": "||",
        "code": "bool Recognizer::loose_match(const Handle& npat_h, const Handle& nsoln_h)"
      },
      {
        "line": 183,
        "operator": "not",
        "replacement": "!",
        "code": "bool Recognizer::fuzzy_match(const Handle& npat_h, const Handle& nsoln_h)"
      },
      {
        "line": 214,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 214,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      }
    ]
  },
  "atomspace/opencog/query/RewriteMixin.cc": {
    "alt_operators": [
      {
        "line": 211,
        "operator": "and",
        "replacement": "&&",
        "code": "if (v->is_atom())"
      }
    ]
  },
  "atomspace/opencog/query/Satisfier.cc": {
    "alt_operators": [
      {
        "line": 76,
        "operator": "not",
        "replacement": "!",
        "code": "return true;"
      },
      {
        "line": 95,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 232,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "atomspace/opencog/query/Satisfier.h": {
    "alt_operators": [
      {
        "line": 39,
        "operator": "not",
        "replacement": "!",
        "code": "* This class is meant to be used with the pattern matcher. When the"
      }
    ]
  },
  "atomspace/opencog/query/SatisfyMixin.cc": {
    "alt_operators": [
      {
        "line": 182,
        "operator": "not",
        "replacement": "!",
        "code": "* in a particular virtual clause have been found, that clause can be"
      },
      {
        "line": 189,
        "operator": "not",
        "replacement": "!",
        "code": "* in this way."
      },
      {
        "line": 326,
        "operator": "or",
        "replacement": "||",
        "code": "* assumed to be listed using the ListLink type. So, for example:"
      },
      {
        "line": 341,
        "operator": "and",
        "replacement": "&&",
        "code": "* The clauses are assumed to be connected by variables, i.e. each"
      },
      {
        "line": 364,
        "operator": "not",
        "replacement": "!",
        "code": "* initial starting point for the search, && thus the search defacto"
      },
      {
        "line": 364,
        "operator": "and",
        "replacement": "&&",
        "code": "* initial starting point for the search, && thus the search defacto"
      }
    ]
  },
  "atomspace/opencog/query/TermMatchMixin.cc": {
    "alt_operators": [
      {
        "line": 102,
        "operator": "and",
        "replacement": "&&",
        "code": "* be compared to a possibly matching node in the atomspace."
      },
      {
        "line": 133,
        "operator": "not",
        "replacement": "!",
        "code": "if (VARIABLE_NODE != pattype && GLOB_NODE != pattype) return true;"
      },
      {
        "line": 133,
        "operator": "and",
        "replacement": "&&",
        "code": "if (VARIABLE_NODE != pattype && GLOB_NODE != pattype) return true;"
      },
      {
        "line": 159,
        "operator": "not",
        "replacement": "!",
        "code": "* link in the atomspace. The first argument"
      },
      {
        "line": 160,
        "operator": "not",
        "replacement": "!",
        "code": "* is a link from the pattern, && the second"
      },
      {
        "line": 160,
        "operator": "and",
        "replacement": "&&",
        "code": "* is a link from the pattern, && the second"
      },
      {
        "line": 161,
        "operator": "not",
        "replacement": "!",
        "code": "* is a possible solution link from the atomspace."
      },
      {
        "line": 161,
        "operator": "and",
        "replacement": "&&",
        "code": "* is a possible solution link from the atomspace."
      },
      {
        "line": 178,
        "operator": "and",
        "replacement": "&&",
        "code": "// at it when the contents of the ChoiceLink are examined."
      },
      {
        "line": 201,
        "operator": "and",
        "replacement": "&&",
        "code": "OC_ASSERT(nullptr == _pat_bound_vars,"
      },
      {
        "line": 231,
        "operator": "and",
        "replacement": "&&",
        "code": "Type pattype = lpat->get_type();"
      },
      {
        "line": 241,
        "operator": "or",
        "replacement": "||",
        "code": "//"
      },
      {
        "line": 259,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 270,
        "operator": "not",
        "replacement": "!",
        "code": "/// nested ChoiceLinks. So, sadly, this code is fairly complex. :-("
      },
      {
        "line": 271,
        "operator": "not",
        "replacement": "!",
        "code": "bool TermMatchMixin::is_self_ground(const Handle& ptrn,"
      },
      {
        "line": 363,
        "operator": "not",
        "replacement": "!",
        "code": "// So just fall through and do the normal recursion below."
      },
      {
        "line": 374,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 529,
        "operator": "not",
        "replacement": "!",
        "code": "//       ListLink"
      },
      {
        "line": 536,
        "operator": "or",
        "replacement": "||",
        "code": "//       Arg1Atom"
      },
      {
        "line": 543,
        "operator": "or",
        "replacement": "||",
        "code": "//       PredicateNode \"blah\"  ; not Grounded any more, and scm: stripped"
      },
      {
        "line": 546,
        "operator": "not",
        "replacement": "!",
        "code": "//           Arg2Atom"
      },
      {
        "line": 556,
        "operator": "not",
        "replacement": "!",
        "code": "// However, we also want to have a side-effect: the result of"
      }
    ]
  },
  "cogutil/include/win32/getopt.h": {
    "posix_headers": [
      {
        "line": 62,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ]
  },
  "cogutil/opencog/util/Config.cc": {
    "posix_headers": [
      {
        "line": 45,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 117,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 139,
        "operator": "or",
        "replacement": "||",
        "code": "if (fin and fin.good() and fin.is_open())"
      },
      {
        "line": 162,
        "operator": "and",
        "replacement": "&&",
        "code": "filename = DEFAULT_CONFIG_FILENAME;"
      },
      {
        "line": 168,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 195,
        "operator": "and",
        "replacement": "&&",
        "code": "// printing is happening \"too early\", before the logger is"
      }
    ]
  },
  "cogutil/opencog/util/Counter.h": {
    "alt_operators": [
      {
        "line": 112,
        "operator": "and",
        "replacement": "&&",
        "code": "T key = super::begin()->first;"
      }
    ]
  },
  "cogutil/opencog/util/Logger.cc": {
    "posix_headers": [
      {
        "line": 96,
        "header": "strings.h",
        "windows_equiv": [
          "string.h"
        ],
        "code": "#include <strings.h>"
      },
      {
        "line": 97,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      },
      {
        "line": 98,
        "header": "sys/time.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <sys/time.h>"
      }
    ]
  },
  "cogutil/opencog/util/async_buffer.h": {
    "posix_headers": [
      {
        "line": 37,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h> /* for usleep() */"
      }
    ],
    "alt_operators": [
      {
        "line": 255,
        "operator": "not",
        "replacement": "!",
        "code": "/// mode. So perhaps we need a better name for this function?"
      },
      {
        "line": 348,
        "operator": "and",
        "replacement": "&&",
        "code": "// I.e. cancel all the threads."
      },
      {
        "line": 377,
        "operator": "not",
        "replacement": "!",
        "code": "void async_buffer<Writer, Element>::drain()"
      }
    ]
  },
  "cogutil/opencog/util/async_method_caller.h": {
    "alt_operators": [
      {
        "line": 195,
        "operator": "not",
        "replacement": "!",
        "code": "stop_writer_threads();"
      }
    ]
  },
  "cogutil/opencog/util/backtrace-symbols.c": {
    "posix_headers": [
      {
        "line": 77,
        "header": "dlfcn.h",
        "windows_equiv": [
          "Windows.h (LoadLibrary)"
        ],
        "code": "#include <dlfcn.h>"
      }
    ]
  },
  "cogutil/opencog/util/concurrent_queue.h": {
    "alt_operators": [
      {
        "line": 48,
        "operator": "not",
        "replacement": "!",
        "code": "/// queue, and any other thread can remove stuff from it.  If the queue"
      },
      {
        "line": 126,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 126,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 154,
        "operator": "not",
        "replacement": "!",
        "code": "// wakes up, && yet the queue is empty.  And calling front()"
      },
      {
        "line": 154,
        "operator": "and",
        "replacement": "&&",
        "code": "// wakes up, && yet the queue is empty.  And calling front()"
      },
      {
        "line": 178,
        "operator": "not",
        "replacement": "!",
        "code": "std::queue<Element> wait_and_take_all()"
      },
      {
        "line": 178,
        "operator": "and",
        "replacement": "&&",
        "code": "std::queue<Element> wait_and_take_all()"
      }
    ]
  },
  "cogutil/opencog/util/concurrent_set.h": {
    "alt_operators": [
      {
        "line": 61,
        "operator": "not",
        "replacement": "!",
        "code": "/// compared to items placed in a queue/stack."
      },
      {
        "line": 222,
        "operator": "not",
        "replacement": "!",
        "code": "// forward iterators. Also, there is no erase() that"
      },
      {
        "line": 222,
        "operator": "and",
        "replacement": "&&",
        "code": "// forward iterators. Also, there is no erase() that"
      },
      {
        "line": 251,
        "operator": "not",
        "replacement": "!",
        "code": "// wakes up, && yet the set is empty."
      },
      {
        "line": 251,
        "operator": "and",
        "replacement": "&&",
        "code": "// wakes up, && yet the set is empty."
      },
      {
        "line": 275,
        "operator": "not",
        "replacement": "!",
        "code": "std::set<Element> wait_and_take_all()"
      },
      {
        "line": 275,
        "operator": "and",
        "replacement": "&&",
        "code": "std::set<Element> wait_and_take_all()"
      }
    ]
  },
  "cogutil/opencog/util/concurrent_stack.h": {
    "alt_operators": [
      {
        "line": 48,
        "operator": "not",
        "replacement": "!",
        "code": "/// stack, and any other thread can remove stuff from it.  If the stack"
      },
      {
        "line": 125,
        "operator": "not",
        "replacement": "!",
        "code": "size_t size() const"
      },
      {
        "line": 125,
        "operator": "and",
        "replacement": "&&",
        "code": "size_t size() const"
      },
      {
        "line": 153,
        "operator": "not",
        "replacement": "!",
        "code": "// wakes up, && yet the stack is empty.  And calling front()"
      },
      {
        "line": 153,
        "operator": "and",
        "replacement": "&&",
        "code": "// wakes up, && yet the stack is empty.  And calling front()"
      },
      {
        "line": 177,
        "operator": "not",
        "replacement": "!",
        "code": "std::stack<Element> wait_and_take_all()"
      },
      {
        "line": 177,
        "operator": "and",
        "replacement": "&&",
        "code": "std::stack<Element> wait_and_take_all()"
      }
    ]
  },
  "cogutil/opencog/util/numeric.h": {
    "alt_operators": [
      {
        "line": 120,
        "operator": "and",
        "replacement": "&&",
        "code": "/// #define ALIGNED_NOT_ACTUALLY_REQUIRED 1 is set."
      },
      {
        "line": 190,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 220,
        "operator": "and",
        "replacement": "&&",
        "code": "* Compute entropy of an n-ary probability distribution, with the"
      }
    ]
  },
  "cogutil/opencog/util/platform.cc": {
    "posix_headers": [
      {
        "line": 136,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      },
      {
        "line": 180,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>   // for sbrk(), sysconf()"
      }
    ]
  },
  "cogutil/opencog/util/tree.h": {
    "alt_operators": [
      {
        "line": 630,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 631,
        "operator": "not",
        "replacement": "!",
        "code": "template <class T, class tree_node_allocator>"
      }
    ]
  },
  "cogutil/opencog/util/zipf.h": {
    "alt_operators": [
      {
        "line": 113,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 123,
        "operator": "not",
        "replacement": "!",
        "code": "RealType   H_n;   ///< H(n)"
      }
    ]
  },
  "cogserver/opencog/cogserver/modules/commands/BuiltinRequestsModule.cc": {
    "posix_headers": [
      {
        "line": 29,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ]
  },
  "cogserver/opencog/cogserver/modules/python/PythonModule.cc": {
    "alt_operators": [
      {
        "line": 81,
        "operator": "not",
        "replacement": "!",
        "code": "logger().info(\"[PythonModule] Initialising Python CogServer module.\");"
      }
    ]
  },
  "cogserver/opencog/cogserver/server/CogServer.cc": {
    "posix_headers": [
      {
        "line": 20,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      },
      {
        "line": 22,
        "header": "sys/time.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <sys/time.h>"
      }
    ]
  },
  "cogserver/opencog/cogserver/server/CogServerMain.cc": {
    "alt_operators": [
      {
        "line": 133,
        "operator": "not",
        "replacement": "!",
        "code": "// unknown option (|| help)"
      },
      {
        "line": 133,
        "operator": "or",
        "replacement": "||",
        "code": "// unknown option (|| help)"
      }
    ]
  },
  "cogserver/opencog/cogserver/server/ModuleManager.cc": {
    "posix_headers": [
      {
        "line": 22,
        "header": "dlfcn.h",
        "windows_equiv": [
          "Windows.h (LoadLibrary)"
        ],
        "code": "#include <dlfcn.h>"
      },
      {
        "line": 24,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 365,
        "operator": "not",
        "replacement": "!",
        "code": "\"libscheme-shell.so, \""
      }
    ]
  },
  "cogserver/opencog/cogserver/server/RequestManager.cc": {
    "posix_headers": [
      {
        "line": 24,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      },
      {
        "line": 26,
        "header": "sys/time.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <sys/time.h>"
      }
    ]
  },
  "cogserver/opencog/cogserver/server/ServerConsole.cc": {
    "alt_operators": [
      {
        "line": 94,
        "operator": "or",
        "replacement": "||",
        "code": "unsigned char c = line[i];"
      },
      {
        "line": 164,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 178,
        "operator": "or",
        "replacement": "||",
        "code": "unsigned char ok[] = {'\\n', 0};"
      },
      {
        "line": 179,
        "operator": "or",
        "replacement": "||",
        "code": "Send((const char *) ok);"
      }
    ]
  },
  "cogserver/opencog/cogserver/shell/JsonShellModule.cc": {
    "alt_operators": [
      {
        "line": 50,
        "operator": "or",
        "replacement": "||",
        "code": "_cogserver.unregisterRequest(shelloutRequest::info().id);"
      }
    ]
  },
  "cogserver/opencog/cogserver/shell/SexprShellModule.cc": {
    "alt_operators": [
      {
        "line": 54,
        "operator": "or",
        "replacement": "||",
        "code": ""
      }
    ]
  },
  "cogserver/opencog/network/GenericShell.cc": {
    "alt_operators": [
      {
        "line": 111,
        "operator": "and",
        "replacement": "&&",
        "code": "show_output = !hush;"
      },
      {
        "line": 167,
        "operator": "not",
        "replacement": "!",
        "code": "//    expression is an infinite loop (or simply is taking too long)"
      },
      {
        "line": 178,
        "operator": "not",
        "replacement": "!",
        "code": "// The above requirements force us to create ! just one, but two"
      },
      {
        "line": 203,
        "operator": "not",
        "replacement": "!",
        "code": "// Queue up the expr, where it will be evaluated in another thread."
      },
      {
        "line": 277,
        "operator": "or",
        "replacement": "||",
        "code": "//"
      },
      {
        "line": 291,
        "operator": "or",
        "replacement": "||",
        "code": "while (m <= i)"
      },
      {
        "line": 292,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 415,
        "operator": "and",
        "replacement": "&&",
        "code": "return;"
      },
      {
        "line": 415,
        "operator": "or",
        "replacement": "||",
        "code": "return;"
      },
      {
        "line": 458,
        "operator": "not",
        "replacement": "!",
        "code": "evalque.push(expr + \"\\n\");"
      },
      {
        "line": 522,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 544,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 568,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 601,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 635,
        "operator": "not",
        "replacement": "!",
        "code": "// That's right, call this twice in a row."
      },
      {
        "line": 680,
        "operator": "and",
        "replacement": "&&",
        "code": "_pending_output += s;"
      },
      {
        "line": 693,
        "operator": "and",
        "replacement": "&&",
        "code": "// If there's pending output, return that."
      }
    ]
  },
  "cogserver/opencog/network/NetworkServer.cc": {
    "posix_headers": [
      {
        "line": 21,
        "header": "sys/socket.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <sys/socket.h>"
      },
      {
        "line": 23,
        "header": "sys/time.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <sys/time.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 53,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 91,
        "operator": "not",
        "replacement": "!",
        "code": "// thread exits).  That is why there is no delete of the *ss"
      }
    ]
  },
  "cogserver/opencog/network/ServerSocket.cc": {
    "alt_operators": [
      {
        "line": 82,
        "operator": "and",
        "replacement": "&&",
        "code": "rc += ss->connection_header() + \"\\n\";"
      },
      {
        "line": 235,
        "operator": "and",
        "replacement": "&&",
        "code": "// The only problem here is that we don't have CAP_SYS_RESOURCE"
      },
      {
        "line": 293,
        "operator": "not",
        "replacement": "!",
        "code": "Exit();"
      },
      {
        "line": 321,
        "operator": "and",
        "replacement": "&&",
        "code": "if (0 == cmdsize) return;"
      },
      {
        "line": 323,
        "operator": "not",
        "replacement": "!",
        "code": "// Avoid lonely newlines. The various shells return these for"
      },
      {
        "line": 422,
        "operator": "not",
        "replacement": "!",
        "code": "//"
      },
      {
        "line": 520,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 529,
        "operator": "not",
        "replacement": "!",
        "code": "asio::streambuf b;"
      },
      {
        "line": 538,
        "operator": "and",
        "replacement": "&&",
        "code": "else"
      },
      {
        "line": 542,
        "operator": "not",
        "replacement": "!",
        "code": "// talk to us, sending us binary garbage of some kind."
      },
      {
        "line": 542,
        "operator": "and",
        "replacement": "&&",
        "code": "// talk to us, sending us binary garbage of some kind."
      },
      {
        "line": 552,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 557,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 602,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 612,
        "operator": "not",
        "replacement": "!",
        "code": "// there may still be some bytes sitting in the buffer. Get"
      },
      {
        "line": 612,
        "operator": "and",
        "replacement": "&&",
        "code": "// there may still be some bytes sitting in the buffer. Get"
      },
      {
        "line": 615,
        "operator": "not",
        "replacement": "!",
        "code": "// newlines at the end."
      }
    ]
  },
  "cogserver/opencog/network/WebSocket.cc": {
    "alt_operators": [
      {
        "line": 33,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 108,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 228,
        "operator": "not",
        "replacement": "!",
        "code": "/// socket, with keep-alive set. In either case, the remaining I/O gets"
      },
      {
        "line": 252,
        "operator": "not",
        "replacement": "!",
        "code": "return;"
      },
      {
        "line": 252,
        "operator": "and",
        "replacement": "&&",
        "code": "return;"
      },
      {
        "line": 258,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 297,
        "operator": "not",
        "replacement": "!",
        "code": "//     closed at any time with `throw SilentException()` to"
      }
    ]
  },
  "atomspace-storage/opencog/persist/api/BackingQuery.cc": {
    "alt_operators": [
      {
        "line": 176,
        "operator": "not",
        "replacement": "!",
        "code": "/// a desirable ideal. Asking users to \"do it themselves\" for the remote"
      }
    ]
  },
  "atomspace-storage/opencog/persist/api/PersistSCM.cc": {
    "alt_operators": [
      {
        "line": 81,
        "operator": "not",
        "replacement": "!",
        "code": "// some checking regarding frames and read-only AtomSpaces, and only"
      }
    ]
  },
  "atomspace-storage/opencog/persist/api/StorageNode.cc": {
    "alt_operators": [
      {
        "line": 132,
        "operator": "not",
        "replacement": "!",
        "code": "return;"
      },
      {
        "line": 140,
        "operator": "not",
        "replacement": "!",
        "code": "return;"
      },
      {
        "line": 151,
        "operator": "not",
        "replacement": "!",
        "code": "return;"
      },
      {
        "line": 164,
        "operator": "not",
        "replacement": "!",
        "code": "if (2 > nv) return;"
      },
      {
        "line": 180,
        "operator": "not",
        "replacement": "!",
        "code": "if (value->is_type(ATOM))"
      },
      {
        "line": 203,
        "operator": "not",
        "replacement": "!",
        "code": "size_t nv = vsq.size();"
      },
      {
        "line": 219,
        "operator": "not",
        "replacement": "!",
        "code": "if (value->is_type(ATOM))"
      },
      {
        "line": 361,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 361,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 416,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 443,
        "operator": "not",
        "replacement": "!",
        "code": "return lh;"
      },
      {
        "line": 443,
        "operator": "and",
        "replacement": "&&",
        "code": "return lh;"
      },
      {
        "line": 532,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 570,
        "operator": "not",
        "replacement": "!",
        "code": "Handle atm(HandleCast(vp));"
      },
      {
        "line": 584,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 602,
        "operator": "not",
        "replacement": "!",
        "code": "continue;"
      }
    ]
  },
  "atomspace-storage/opencog/persist/csv/table_read.cc": {
    "alt_operators": [
      {
        "line": 120,
        "operator": "not",
        "replacement": "!",
        "code": "// Remove carriage return at end of line (for DOS files)."
      }
    ]
  },
  "atomspace-storage/opencog/persist/file/FileStorage.cc": {
    "posix_headers": [
      {
        "line": 33,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ]
  },
  "atomspace-storage/opencog/persist/file/fast_load.cc": {
    "alt_operators": [
      {
        "line": 85,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      }
    ]
  },
  "atomspace-storage/opencog/persist/json/DecodeJson.cc": {
    "alt_operators": [
      {
        "line": 104,
        "operator": "and",
        "replacement": "&&",
        "code": "if ('{' == tna[pos])"
      },
      {
        "line": 104,
        "operator": "or",
        "replacement": "||",
        "code": "if ('{' == tna[pos])"
      }
    ]
  },
  "atomspace-storage/opencog/persist/json/EncodeJson.cc": {
    "alt_operators": [
      {
        "line": 42,
        "operator": "not",
        "replacement": "!",
        "code": "ss << indent << \"{\\n\" << indent << \"  \\\"type\\\": \\\"\""
      },
      {
        "line": 90,
        "operator": "not",
        "replacement": "!",
        "code": "if (nullptr == v) return \"false\";"
      },
      {
        "line": 104,
        "operator": "not",
        "replacement": "!",
        "code": "// form of the value, as compared to SimpleTruthValue, which"
      },
      {
        "line": 122,
        "operator": "not",
        "replacement": "!",
        "code": "bool first = true;"
      },
      {
        "line": 150,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 167,
        "operator": "not",
        "replacement": "!",
        "code": "rv << \"[\\n\";"
      }
    ]
  },
  "atomspace-storage/opencog/persist/json/JSCommands.cc": {
    "alt_operators": [
      {
        "line": 102,
        "operator": "and",
        "replacement": "&&",
        "code": "// now a text string. Hurrah. Well, for now, it seems that at least"
      },
      {
        "line": 326,
        "operator": "not",
        "replacement": "!",
        "code": "nameserver().getParents(t, std::back_inserter(vect));"
      },
      {
        "line": 348,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 374,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 500,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 518,
        "operator": "not",
        "replacement": "!",
        "code": "for (const Handle& hi : is)"
      },
      {
        "line": 637,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "atomspace-storage/opencog/persist/json/JsonEval.cc": {
    "posix_headers": [
      {
        "line": 28,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h> /* for usleep() */"
      }
    ]
  },
  "atomspace-storage/opencog/persist/prolog/DecodeProlog.cc": {
    "alt_operators": [
      {
        "line": 60,
        "operator": "or",
        "replacement": "||",
        "code": "if ('_' == c || isupper(c))"
      },
      {
        "line": 80,
        "operator": "or",
        "replacement": "||",
        "code": "l = sexpr.find_first_not_of(\" \\t\\n\", r);"
      }
    ]
  },
  "atomspace-storage/opencog/persist/prolog/EncodeProlog.cc": {
    "alt_operators": [
      {
        "line": 43,
        "operator": "not",
        "replacement": "!",
        "code": "for (const Handle& ho: h->getOutgoingSet())"
      }
    ]
  },
  "atomspace-storage/opencog/persist/proxy/CachingProxy.cc": {
    "alt_operators": [
      {
        "line": 41,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.cc": {
    "alt_operators": [
      {
        "line": 50,
        "operator": "not",
        "replacement": "!",
        "code": "void DynamicDataProxy::getAtom(const Handle& h)"
      }
    ]
  },
  "atomspace-storage/opencog/persist/proxy/ProxyNode.cc": {
    "alt_operators": [
      {
        "line": 86,
        "operator": "not",
        "replacement": "!",
        "code": "void ProxyNode::setValue(const Handle& key, const ValuePtr& value)"
      }
    ]
  },
  "atomspace-storage/opencog/persist/proxy/ReadWriteProxy.cc": {
    "alt_operators": [
      {
        "line": 120,
        "operator": "not",
        "replacement": "!",
        "code": "CHECK_OPEN"
      }
    ]
  },
  "atomspace-storage/opencog/persist/proxy/WriteBufferProxy.cc": {
    "posix_headers": [
      {
        "line": 29,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 56,
        "operator": "not",
        "replacement": "!",
        "code": "_decay = 60.0;"
      },
      {
        "line": 156,
        "operator": "not",
        "replacement": "!",
        "code": "IncomingSet ris(h->getIncomingSet());"
      },
      {
        "line": 310,
        "operator": "not",
        "replacement": "!",
        "code": "// Cycle time. Write-outs happen at least every ten seconds."
      }
    ]
  },
  "atomspace-storage/opencog/persist/proxy/WriteThruProxy.cc": {
    "alt_operators": [
      {
        "line": 55,
        "operator": "not",
        "replacement": "!",
        "code": "_targets.swap(sns);"
      }
    ]
  },
  "atomspace-storage/opencog/persist/sexcom/Commands.cc": {
    "alt_operators": [
      {
        "line": 44,
        "operator": "not",
        "replacement": "!",
        "code": "/// the internet. The actual API is that of the StorageNode (see the"
      },
      {
        "line": 70,
        "operator": "not",
        "replacement": "!",
        "code": "return _base_space.get();"
      },
      {
        "line": 93,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 152,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 152,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 180,
        "operator": "and",
        "replacement": "&&",
        "code": "else"
      },
      {
        "line": 183,
        "operator": "and",
        "replacement": "&&",
        "code": "_base_space->set_value(query, key, rslt);"
      },
      {
        "line": 202,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 224,
        "operator": "and",
        "replacement": "&&",
        "code": "else"
      },
      {
        "line": 246,
        "operator": "and",
        "replacement": "&&",
        "code": "_proxy->fetch_incoming_by_type(h, t);"
      },
      {
        "line": 271,
        "operator": "and",
        "replacement": "&&",
        "code": "else"
      },
      {
        "line": 302,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 325,
        "operator": "and",
        "replacement": "&&",
        "code": "_proxy->barrier();"
      },
      {
        "line": 340,
        "operator": "and",
        "replacement": "&&",
        "code": "Type t = Sexpr::decode_type(cmd, pos);"
      },
      {
        "line": 365,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 383,
        "operator": "and",
        "replacement": "&&",
        "code": "key = as->add_atom(key);"
      },
      {
        "line": 401,
        "operator": "and",
        "replacement": "&&",
        "code": "if (nullptr == h) return \"#t\";"
      },
      {
        "line": 427,
        "operator": "and",
        "replacement": "&&",
        "code": "if (_base_space->extract_atom(h, true)) return \"#t\";"
      },
      {
        "line": 442,
        "operator": "not",
        "replacement": "!",
        "code": "key = as->add_atom(key);"
      },
      {
        "line": 455,
        "operator": "and",
        "replacement": "&&",
        "code": "//     (alist (cons (Predicate \"bar\") (stv 0.9 0.8)) ...))"
      },
      {
        "line": 483,
        "operator": "and",
        "replacement": "&&",
        "code": "// (cog-set-tv! (Concept \"foo\") (stv 1 0) (AtomSpace \"foo\"))"
      },
      {
        "line": 502,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 508,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "atomspace-storage/opencog/persist/sexcom/SexprEval.cc": {
    "posix_headers": [
      {
        "line": 28,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h> /* for usleep() */"
      }
    ]
  },
  "atomspace-storage/opencog/persist/sexpr/AtomSexpr.cc": {
    "alt_operators": [
      {
        "line": 58,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 60,
        "operator": "and",
        "replacement": "&&",
        "code": "throw SyntaxException(TRACE_INFO,"
      }
    ]
  },
  "atomspace-storage/opencog/persist/sexpr/FrameSexpr.cc": {
    "alt_operators": [
      {
        "line": 147,
        "operator": "or",
        "replacement": "||",
        "code": "/// a null pointer."
      },
      {
        "line": 181,
        "operator": "and",
        "replacement": "&&",
        "code": "// If we were given a DAG to search, search it."
      }
    ]
  },
  "atomspace-storage/opencog/persist/sexpr/ValueSexpr.cc": {
    "alt_operators": [
      {
        "line": 47,
        "operator": "and",
        "replacement": "&&",
        "code": "throw SyntaxException(TRACE_INFO, \"Bad Type >>%s<<\","
      },
      {
        "line": 83,
        "operator": "not",
        "replacement": "!",
        "code": "* and/or contain bugs if it is given strings of unexpected formats."
      }
    ]
  },
  "atomspace-storage/opencog/persist/tlb/TLB.cc": {
    "alt_operators": [
      {
        "line": 63,
        "operator": "and",
        "replacement": "&&",
        "code": "Handle TLB::do_res(const Handle& h)"
      },
      {
        "line": 83,
        "operator": "or",
        "replacement": "||",
        "code": "if (hr != h and h->is_link())"
      },
      {
        "line": 121,
        "operator": "and",
        "replacement": "&&",
        "code": "// Oh wait, is it being used already?"
      }
    ]
  },
  "atomspace-rocks/opencog/persist/monospace/MonoIO.cc": {
    "alt_operators": [
      {
        "line": 199,
        "operator": "not",
        "replacement": "!",
        "code": "/// Return the matching sid."
      },
      {
        "line": 236,
        "operator": "not",
        "replacement": "!",
        "code": "// start using it in other records.  We want to avoid issuing it"
      },
      {
        "line": 311,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 311,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 327,
        "operator": "not",
        "replacement": "!",
        "code": "/// Append to incoming set."
      },
      {
        "line": 339,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 356,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 370,
        "operator": "and",
        "replacement": "&&",
        "code": "void MonoStorage::loadValue(const Handle& h, const Handle& key)"
      },
      {
        "line": 412,
        "operator": "and",
        "replacement": "&&",
        "code": "#endif"
      },
      {
        "line": 534,
        "operator": "not",
        "replacement": "!",
        "code": "void MonoStorage::removeAtom(AtomSpace* as, const Handle& h, bool recursive)"
      },
      {
        "line": 601,
        "operator": "and",
        "replacement": "&&",
        "code": "remFromInset(ist, sid);"
      },
      {
        "line": 636,
        "operator": "and",
        "replacement": "&&",
        "code": "sidlist.replace(pos, sidlen, \"\");"
      },
      {
        "line": 640,
        "operator": "not",
        "replacement": "!",
        "code": "_rfile->Put(rocksdb::WriteOptions(), klist, sidlist);"
      },
      {
        "line": 676,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 680,
        "operator": "not",
        "replacement": "!",
        "code": "std::string isatom;"
      },
      {
        "line": 715,
        "operator": "not",
        "replacement": "!",
        "code": "_rfile->Get(rocksdb::ReadOptions(), \"a@\" + isid + \":\", &isatom);"
      },
      {
        "line": 732,
        "operator": "or",
        "replacement": "||",
        "code": "remFromSidList(shash, sid);"
      },
      {
        "line": 771,
        "operator": "and",
        "replacement": "&&",
        "code": "try"
      },
      {
        "line": 787,
        "operator": "not",
        "replacement": "!",
        "code": "std::string pfx = is_node ? \"n@\" : \"l@\";"
      },
      {
        "line": 800,
        "operator": "not",
        "replacement": "!",
        "code": "// Work with the incoming set"
      },
      {
        "line": 810,
        "operator": "and",
        "replacement": "&&",
        "code": "if (not s.ok())"
      },
      {
        "line": 838,
        "operator": "and",
        "replacement": "&&",
        "code": "size_t nsk = 0;"
      },
      {
        "line": 883,
        "operator": "and",
        "replacement": "&&",
        "code": "std::string ist = \"i@\" + sid + \":\";"
      },
      {
        "line": 910,
        "operator": "and",
        "replacement": "&&",
        "code": "as->storage_add_nocheck(h);"
      },
      {
        "line": 973,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 987,
        "operator": "and",
        "replacement": "&&",
        "code": "_next_aid = 1;"
      },
      {
        "line": 1005,
        "operator": "and",
        "replacement": "&&",
        "code": "size_t MonoStorage::count_records(const std::string& pfx)"
      },
      {
        "line": 1013,
        "operator": "not",
        "replacement": "!",
        "code": "delete it;"
      }
    ]
  },
  "atomspace-rocks/opencog/persist/rocks/RocksDAG.cc": {
    "alt_operators": [
      {
        "line": 80,
        "operator": "not",
        "replacement": "!",
        "code": "auto it = _frame_map.find(hasp);"
      },
      {
        "line": 165,
        "operator": "and",
        "replacement": "&&",
        "code": "// It is safe to dereference fas.get() because fas is"
      },
      {
        "line": 199,
        "operator": "not",
        "replacement": "!",
        "code": "// Get all spaces that are subspaces"
      },
      {
        "line": 262,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "atomspace-rocks/opencog/persist/rocks/RocksFrame.cc": {
    "alt_operators": [
      {
        "line": 58,
        "operator": "and",
        "replacement": "&&",
        "code": "std::lock_guard<std::mutex> flck(_mtx_frame);"
      },
      {
        "line": 66,
        "operator": "and",
        "replacement": "&&",
        "code": "// I'm too lazy to implement delete-from-the-middle. So throw"
      },
      {
        "line": 106,
        "operator": "not",
        "replacement": "!",
        "code": "// Finally, remove it from out own tables."
      },
      {
        "line": 129,
        "operator": "and",
        "replacement": "&&",
        "code": "if (not (it->Valid() && it->key().starts_with(pfx)))"
      },
      {
        "line": 138,
        "operator": "and",
        "replacement": "&&",
        "code": "size_t osz = bot->get_arity();"
      },
      {
        "line": 175,
        "operator": "not",
        "replacement": "!",
        "code": "// If there were no keys, write the marker."
      },
      {
        "line": 181,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 187,
        "operator": "not",
        "replacement": "!",
        "code": "\"z\" + aidtostr(height) + \"@\" + sid, \"\");"
      },
      {
        "line": 187,
        "operator": "and",
        "replacement": "&&",
        "code": "\"z\" + aidtostr(height) + \"@\" + sid, \"\");"
      },
      {
        "line": 213,
        "operator": "not",
        "replacement": "!",
        "code": "// and ignore that as a special case."
      },
      {
        "line": 219,
        "operator": "and",
        "replacement": "&&",
        "code": "delete it;"
      },
      {
        "line": 225,
        "operator": "and",
        "replacement": "&&",
        "code": "return false;"
      },
      {
        "line": 243,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      }
    ]
  },
  "atomspace-rocks/opencog/persist/rocks/RocksIO.cc": {
    "alt_operators": [
      {
        "line": 260,
        "operator": "not",
        "replacement": "!",
        "code": "std::string RocksStorage::writeAtom(const Handle& h, bool need_mark)"
      },
      {
        "line": 271,
        "operator": "and",
        "replacement": "&&",
        "code": "if (convertible)"
      },
      {
        "line": 311,
        "operator": "not",
        "replacement": "!",
        "code": "_rfile->Put(rocksdb::WriteOptions(), pfx + satom, sid);"
      },
      {
        "line": 311,
        "operator": "or",
        "replacement": "||",
        "code": "_rfile->Put(rocksdb::WriteOptions(), pfx + satom, sid);"
      },
      {
        "line": 315,
        "operator": "not",
        "replacement": "!",
        "code": "appendToSidList(shash, sid);"
      },
      {
        "line": 315,
        "operator": "and",
        "replacement": "&&",
        "code": "appendToSidList(shash, sid);"
      },
      {
        "line": 322,
        "operator": "not",
        "replacement": "!",
        "code": "_rfile->Put(rocksdb::WriteOptions(), oid, \"\");"
      },
      {
        "line": 363,
        "operator": "not",
        "replacement": "!",
        "code": "size_t height = getHeight(h);"
      },
      {
        "line": 446,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 446,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 462,
        "operator": "not",
        "replacement": "!",
        "code": "/// Append to incoming set."
      },
      {
        "line": 474,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 498,
        "operator": "and",
        "replacement": "&&",
        "code": "throw IOException(TRACE_INFO, \"Internal Error!\");"
      },
      {
        "line": 503,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 522,
        "operator": "and",
        "replacement": "&&",
        "code": "fid = \":\" + writeFrame(as);"
      },
      {
        "line": 596,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 606,
        "operator": "not",
        "replacement": "!",
        "code": "/// unexpected, subtle side-effects. It's ! clear what the best"
      },
      {
        "line": 650,
        "operator": "not",
        "replacement": "!",
        "code": "ValuePtr vp = Sexpr::decode_value(it->value().ToString(), junk);"
      },
      {
        "line": 762,
        "operator": "not",
        "replacement": "!",
        "code": "if (0 == alfali.size()) return Handle::UNDEFINED;"
      },
      {
        "line": 762,
        "operator": "and",
        "replacement": "&&",
        "code": "if (0 == alfali.size()) return Handle::UNDEFINED;"
      },
      {
        "line": 774,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 812,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 873,
        "operator": "and",
        "replacement": "&&",
        "code": "remFromInset(ist, sid);"
      },
      {
        "line": 907,
        "operator": "and",
        "replacement": "&&",
        "code": "// from it, && store it as the new sidlist. Unless its empty..."
      },
      {
        "line": 911,
        "operator": "not",
        "replacement": "!",
        "code": "else"
      },
      {
        "line": 945,
        "operator": "not",
        "replacement": "!",
        "code": "std::string isatom;"
      },
      {
        "line": 962,
        "operator": "or",
        "replacement": "||",
        "code": "remFromSidList(shash, sid);"
      },
      {
        "line": 1001,
        "operator": "and",
        "replacement": "&&",
        "code": "try"
      },
      {
        "line": 1014,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 1023,
        "operator": "not",
        "replacement": "!",
        "code": "it = _rfile->NewIterator(rocksdb::ReadOptions());"
      },
      {
        "line": 1041,
        "operator": "and",
        "replacement": "&&",
        "code": "void RocksStorage::remFromInset(const std::string& klist,"
      },
      {
        "line": 1050,
        "operator": "not",
        "replacement": "!",
        "code": "/// Load the incoming set based on the key prefix `ist`."
      },
      {
        "line": 1094,
        "operator": "and",
        "replacement": "&&",
        "code": "std::string sid = findAtom(h);"
      },
      {
        "line": 1115,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 1142,
        "operator": "and",
        "replacement": "&&",
        "code": "const std::string& sid = it->value().ToString();"
      },
      {
        "line": 1167,
        "operator": "not",
        "replacement": "!",
        "code": "cnt ++;"
      },
      {
        "line": 1188,
        "operator": "not",
        "replacement": "!",
        "code": "void RocksStorage::loadAtomsAllFrames(AtomSpace* as)"
      },
      {
        "line": 1213,
        "operator": "and",
        "replacement": "&&",
        "code": "loadAtoms(table);"
      },
      {
        "line": 1226,
        "operator": "not",
        "replacement": "!",
        "code": "/// Load all atoms of type `t`. Not suitable for multi-space loading."
      },
      {
        "line": 1242,
        "operator": "not",
        "replacement": "!",
        "code": "delete it;"
      },
      {
        "line": 1260,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 1260,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 1261,
        "operator": "and",
        "replacement": "&&",
        "code": "void RocksStorage::loadType(AtomSpace* as, Type t)"
      },
      {
        "line": 1326,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 1340,
        "operator": "and",
        "replacement": "&&",
        "code": "_next_aid = 1;"
      },
      {
        "line": 1360,
        "operator": "and",
        "replacement": "&&",
        "code": "CHECK_OPEN;"
      },
      {
        "line": 1368,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 1380,
        "operator": "and",
        "replacement": "&&",
        "code": "std::string pfx = \"k@\";"
      }
    ]
  },
  "atomspace-rocks/opencog/persist/rocks/RocksStorage.cc": {
    "alt_operators": [
      {
        "line": 59,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "atomspace-cog/opencog/persist/cog-simple/CogSimpleIO.cc": {
    "alt_operators": [
      {
        "line": 54,
        "operator": "not",
        "replacement": "!",
        "code": "// cogserver, it can handle that just fine."
      },
      {
        "line": 55,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 79,
        "operator": "not",
        "replacement": "!",
        "code": "&& h->getAtomSpace() != _atom_space)"
      },
      {
        "line": 79,
        "operator": "and",
        "replacement": "&&",
        "code": "&& h->getAtomSpace() != _atom_space)"
      },
      {
        "line": 100,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 100,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      }
    ]
  },
  "atomspace-cog/opencog/persist/cog-simple/CogSimpleStorage.cc": {
    "posix_headers": [
      {
        "line": 43,
        "header": "sys/socket.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <sys/socket.h>"
      },
      {
        "line": 46,
        "header": "netdb.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <netdb.h>"
      },
      {
        "line": 48,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 216,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 230,
        "operator": "not",
        "replacement": "!",
        "code": "do_send(\"(cog-proxy-open)\\n\");"
      },
      {
        "line": 266,
        "operator": "and",
        "replacement": "&&",
        "code": "// read."
      },
      {
        "line": 274,
        "operator": "and",
        "replacement": "&&",
        "code": "int len = recv(_sockfd, buf, 4096, 0);"
      },
      {
        "line": 284,
        "operator": "and",
        "replacement": "&&",
        "code": "throw IOException(TRACE_INFO, \"Cogserver unexpectedly closed connection\");"
      },
      {
        "line": 284,
        "operator": "or",
        "replacement": "||",
        "code": "throw IOException(TRACE_INFO, \"Cogserver unexpectedly closed connection\");"
      }
    ]
  },
  "atomspace-cog/opencog/persist/cog-storage/CogChannel.cc": {
    "posix_headers": [
      {
        "line": 44,
        "header": "sys/socket.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <sys/socket.h>"
      },
      {
        "line": 47,
        "header": "netdb.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <netdb.h>"
      },
      {
        "line": 49,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 259,
        "operator": "and",
        "replacement": "&&",
        "code": "// send it's default prompt. That prompt is not newline-terminated."
      },
      {
        "line": 267,
        "operator": "and",
        "replacement": "&&",
        "code": "char buf[8193];"
      },
      {
        "line": 278,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 278,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      }
    ]
  },
  "atomspace-cog/opencog/persist/cog-storage/CogChannel.h": {
    "posix_headers": [
      {
        "line": 39,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h> /* for close() */"
      }
    ]
  },
  "atomspace-cog/opencog/persist/cog-storage/CogStorage.cc": {
    "posix_headers": [
      {
        "line": 38,
        "header": "sys/socket.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <sys/socket.h>"
      },
      {
        "line": 41,
        "header": "netdb.h",
        "windows_equiv": [
          "winsock2.h"
        ],
        "code": "#include <netdb.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 85,
        "operator": "not",
        "replacement": "!",
        "code": "\"Unknown configuration %s\", pcfg.c_str());"
      }
    ]
  },
  "unify/opencog/unify/Unify.cc": {
    "alt_operators": [
      {
        "line": 81,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 109,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 115,
        "operator": "and",
        "replacement": "&&",
        "code": "OC_ASSERT(other_it != other.context.scope_variables.cend(),"
      },
      {
        "line": 131,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 254,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 255,
        "operator": "or",
        "replacement": "||",
        "code": "// Merge the 2 type declarations"
      },
      {
        "line": 309,
        "operator": "or",
        "replacement": "||",
        "code": "// type is merely lhs_vardecl and rhs_vardecl merged together,"
      },
      {
        "line": 402,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 456,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 466,
        "operator": "and",
        "replacement": "&&",
        "code": "vardecl = filter_vardecl(vardecl, hs);"
      },
      {
        "line": 475,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 503,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 518,
        "operator": "or",
        "replacement": "||",
        "code": "return createLink(std::move(oset), t);"
      },
      {
        "line": 551,
        "operator": "not",
        "replacement": "!",
        "code": "const AtomSpace* as)"
      },
      {
        "line": 579,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 579,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 589,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 592,
        "operator": "or",
        "replacement": "||",
        "code": "Context lc, Context rc) const"
      },
      {
        "line": 605,
        "operator": "and",
        "replacement": "&&",
        "code": "CHandle lch(lh, lc);"
      },
      {
        "line": 614,
        "operator": "and",
        "replacement": "&&",
        "code": "// they are different, then unifies."
      },
      {
        "line": 664,
        "operator": "and",
        "replacement": "&&",
        "code": "return ordered_unify(lh->getOutgoingSet(), rh->getOutgoingSet(), lc, rc);"
      },
      {
        "line": 666,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 667,
        "operator": "and",
        "replacement": "&&",
        "code": "Unify::SolutionSet Unify::unordered_unify(const HandleSeq& lhs,"
      },
      {
        "line": 669,
        "operator": "and",
        "replacement": "&&",
        "code": "Context lc, Context rc) const"
      },
      {
        "line": 677,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 683,
        "operator": "and",
        "replacement": "&&",
        "code": "Context lc, Context rc) const"
      },
      {
        "line": 699,
        "operator": "and",
        "replacement": "&&",
        "code": "// of arguments the glob can contain."
      },
      {
        "line": 708,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 740,
        "operator": "not",
        "replacement": "!",
        "code": "auto tail_sol = flip ?"
      },
      {
        "line": 754,
        "operator": "not",
        "replacement": "!",
        "code": "return seq.size() < offset ? seq : HandleSeq(seq.begin() + offset, seq.end());"
      },
      {
        "line": 768,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 786,
        "operator": "and",
        "replacement": "&&",
        "code": "SolutionSet sol(true);"
      },
      {
        "line": 788,
        "operator": "and",
        "replacement": "&&",
        "code": "for (auto rit = std::next(lit); rit != chs.end(); ++rit) {"
      },
      {
        "line": 792,
        "operator": "not",
        "replacement": "!",
        "code": "return sol;"
      },
      {
        "line": 826,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 826,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 860,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 882,
        "operator": "not",
        "replacement": "!",
        "code": "result = join(result, rhs_block);"
      },
      {
        "line": 917,
        "operator": "not",
        "replacement": "!",
        "code": "TypedBlock j_block = join(common_blocks, block);"
      },
      {
        "line": 925,
        "operator": "and",
        "replacement": "&&",
        "code": "SolutionSet sol = subunify(common_blocks, block);"
      },
      {
        "line": 945,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 953,
        "operator": "not",
        "replacement": "!",
        "code": "Unify::SolutionSet Unify::subunify(const TypedBlockSeq& common_blocks,"
      },
      {
        "line": 960,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 995,
        "operator": "not",
        "replacement": "!",
        "code": "return comb_unify(set_symmetric_difference(lhs.first, rhs.first));"
      },
      {
        "line": 996,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 996,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 1012,
        "operator": "not",
        "replacement": "!",
        "code": "if (lhs.size() != rhs.size())"
      },
      {
        "line": 1013,
        "operator": "or",
        "replacement": "||",
        "code": "return false;"
      },
      {
        "line": 1024,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 1025,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 1037,
        "operator": "not",
        "replacement": "!",
        "code": "return false;"
      },
      {
        "line": 1053,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 1083,
        "operator": "or",
        "replacement": "||",
        "code": "result.insert({el.first, val});"
      },
      {
        "line": 1115,
        "operator": "and",
        "replacement": "&&",
        "code": "return inherit(lch.handle, rch.handle, lch.context, rch.context);"
      },
      {
        "line": 1118,
        "operator": "not",
        "replacement": "!",
        "code": "bool Unify::inherit(const Handle& lh, const Handle& rh,"
      },
      {
        "line": 1135,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 1163,
        "operator": "not",
        "replacement": "!",
        "code": "// type inherits from it (using Variables::is_type)."
      },
      {
        "line": 1171,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 1186,
        "operator": "and",
        "replacement": "&&",
        "code": "if (not inherit(ty, rhs))"
      },
      {
        "line": 1191,
        "operator": "and",
        "replacement": "&&",
        "code": "bool Unify::inherit(const std::pair<double, double> &lgm,"
      },
      {
        "line": 1198,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 1198,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 1199,
        "operator": "not",
        "replacement": "!",
        "code": "return _variables.varset_contains(h);"
      },
      {
        "line": 1199,
        "operator": "and",
        "replacement": "&&",
        "code": "return _variables.varset_contains(h);"
      },
      {
        "line": 1213,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 1215,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "unify/opencog/unify/atoms/UnifierLink.cc": {
    "alt_operators": [
      {
        "line": 41,
        "operator": "not",
        "replacement": "!",
        "code": "throw InvalidParamException(TRACE_INFO,"
      },
      {
        "line": 42,
        "operator": "not",
        "replacement": "!",
        "code": "\"Expecting an UnifierLink, got %s\", tname.c_str());"
      }
    ]
  },
  "ure/opencog/ure/BetaDistribution.cc": {
    "alt_operators": [
      {
        "line": 127,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 130,
        "operator": "and",
        "replacement": "&&",
        "code": "return BetaDistribution(tv);"
      },
      {
        "line": 133,
        "operator": "and",
        "replacement": "&&",
        "code": "TruthValuePtr mk_stv(double mean, double variance,"
      },
      {
        "line": 138,
        "operator": "and",
        "replacement": "&&",
        "code": "beta = beta_distribution<double>::find_beta(mean, variance);"
      }
    ]
  },
  "ure/opencog/ure/Rule.cc": {
    "alt_operators": [
      {
        "line": 96,
        "operator": "not",
        "replacement": "!",
        "code": "return {it, true};"
      },
      {
        "line": 103,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 173,
        "operator": "not",
        "replacement": "!",
        "code": "_rule = r._rule;"
      },
      {
        "line": 357,
        "operator": "not",
        "replacement": "!",
        "code": "* Get the implicant (input) of the rule defined in a BindLink."
      },
      {
        "line": 378,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 385,
        "operator": "or",
        "replacement": "||",
        "code": "return false;"
      },
      {
        "line": 415,
        "operator": "not",
        "replacement": "!",
        "code": "// PresentLink(s), as the other clauses can be assumed to be"
      },
      {
        "line": 422,
        "operator": "or",
        "replacement": "||",
        "code": "if (is_present(h)) {"
      },
      {
        "line": 451,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 476,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 491,
        "operator": "not",
        "replacement": "!",
        "code": "return args->getOutgoingAtom(0);"
      },
      {
        "line": 528,
        "operator": "not",
        "replacement": "!",
        "code": "Handle rule_vardecl = alpha_rule.get_vardecl();"
      }
    ]
  },
  "ure/opencog/ure/ThompsonSampling.cc": {
    "alt_operators": [
      {
        "line": 46,
        "operator": "not",
        "replacement": "!",
        "code": "for (const auto& tv : _tvs)"
      }
    ]
  },
  "ure/opencog/ure/URESCM.cc": {
    "alt_operators": [
      {
        "line": 83,
        "operator": "not",
        "replacement": "!",
        "code": "Handle get_rulebase_rules(Handle rbs);"
      },
      {
        "line": 111,
        "operator": "not",
        "replacement": "!",
        "code": "define_scheme_primitive(\"cog-mandatory-args-fc\","
      },
      {
        "line": 114,
        "operator": "not",
        "replacement": "!",
        "code": "define_scheme_primitive(\"cog-mandatory-args-bc\","
      }
    ]
  },
  "ure/opencog/ure/backwardchainer/BIT.cc": {
    "alt_operators": [
      {
        "line": 219,
        "operator": "or",
        "replacement": "||",
        "code": "} else {"
      },
      {
        "line": 220,
        "operator": "and",
        "replacement": "&&",
        "code": "return contains(ancestors, arg);"
      },
      {
        "line": 353,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 433,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 516,
        "operator": "and",
        "replacement": "&&",
        "code": "bool AndBIT::is_argument_of(const Handle& eval, const Handle& atom) const"
      },
      {
        "line": 518,
        "operator": "and",
        "replacement": "&&",
        "code": "if (eval->get_type() == EVALUATION_LINK) {"
      },
      {
        "line": 531,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 684,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 699,
        "operator": "or",
        "replacement": "||",
        "code": "std::string::size_type pos;"
      },
      {
        "line": 739,
        "operator": "not",
        "replacement": "!",
        "code": "word = remove_vowels(word, wrd_tg_size);"
      },
      {
        "line": 762,
        "operator": "or",
        "replacement": "||",
        "code": "lead_sp_size = leading_spaces(up_bl);"
      }
    ]
  },
  "ure/opencog/ure/backwardchainer/BackwardChainer.cc": {
    "alt_operators": [
      {
        "line": 70,
        "operator": "not",
        "replacement": "!",
        "code": "const AndBITFitness& andbit_fitness)"
      },
      {
        "line": 100,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 100,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 185,
        "operator": "not",
        "replacement": "!",
        "code": "// Select leaf"
      }
    ]
  },
  "ure/opencog/ure/backwardchainer/ControlPolicy.cc": {
    "alt_operators": [
      {
        "line": 111,
        "operator": "not",
        "replacement": "!",
        "code": "RuleTypedSubstitutionMap valid_rules;"
      },
      {
        "line": 233,
        "operator": "not",
        "replacement": "!",
        "code": "weights.push_back(alias_weights.get(alias) / alias_counter[alias]);"
      },
      {
        "line": 277,
        "operator": "not",
        "replacement": "!",
        "code": "ctrl_exp_input = ctrl_expansion->getOutgoingAtom(1),"
      },
      {
        "line": 292,
        "operator": "and",
        "replacement": "&&",
        "code": "// Make sure that the variables in the control rule && the actual"
      },
      {
        "line": 293,
        "operator": "and",
        "replacement": "&&",
        "code": "// andbit are disjoint"
      },
      {
        "line": 306,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      }
    ]
  },
  "ure/opencog/ure/backwardchainer/TraceRecorder.cc": {
    "alt_operators": [
      {
        "line": 86,
        "operator": "not",
        "replacement": "!",
        "code": "TruthValue::TRUE_TV());"
      },
      {
        "line": 96,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 111,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 122,
        "operator": "not",
        "replacement": "!",
        "code": "return execution;"
      },
      {
        "line": 134,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "ure/opencog/ure/forwardchainer/ForwardChainer.cc": {
    "alt_operators": [
      {
        "line": 66,
        "operator": "not",
        "replacement": "!",
        "code": "ForwardChainer::ForwardChainer(AtomSpace& kb_as,"
      },
      {
        "line": 139,
        "operator": "not",
        "replacement": "!",
        "code": "// Do steps single-threadedly till termination"
      },
      {
        "line": 150,
        "operator": "not",
        "replacement": "!",
        "code": "// Restore logging thread ID flag"
      },
      {
        "line": 177,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 205,
        "operator": "not",
        "replacement": "!",
        "code": "int lipo = iteration + 1;"
      },
      {
        "line": 290,
        "operator": "and",
        "replacement": "&&",
        "code": "// replaced by do_step_srpi."
      },
      {
        "line": 307,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 436,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 453,
        "operator": "or",
        "replacement": "||",
        "code": "// Try again, in case another source is available"
      },
      {
        "line": 456,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 466,
        "operator": "not",
        "replacement": "!",
        "code": "LAZY_URE_LOG_FINE << msgprfx"
      },
      {
        "line": 519,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 519,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 525,
        "operator": "not",
        "replacement": "!",
        "code": "// Generate all valid rules"
      },
      {
        "line": 612,
        "operator": "or",
        "replacement": "||",
        "code": ""
      }
    ]
  },
  "ure/opencog/ure/forwardchainer/SourceRuleSet.cc": {
    "alt_operators": [
      {
        "line": 34,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 57,
        "operator": "or",
        "replacement": "||",
        "code": "std::string SourceRule::to_string(const std::string& indent) const"
      }
    ]
  },
  "ure/opencog/ure/forwardchainer/SourceSet.cc": {
    "alt_operators": [
      {
        "line": 48,
        "operator": "and",
        "replacement": "&&",
        "code": "// TODO:"
      },
      {
        "line": 55,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 55,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 102,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "miner/opencog/miner/HandleTree.cc": {
    "alt_operators": [
      {
        "line": 89,
        "operator": "not",
        "replacement": "!",
        "code": "// \t// // TODO: remove the following check when we know we can make"
      }
    ]
  },
  "miner/opencog/miner/Miner.cc": {
    "alt_operators": [
      {
        "line": 42,
        "operator": "not",
        "replacement": "!",
        "code": "// 7. make sure that filtering is still meaningfull"
      },
      {
        "line": 150,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 204,
        "operator": "not",
        "replacement": "!",
        "code": "return patterns;"
      }
    ]
  },
  "miner/opencog/miner/MinerUtils.cc": {
    "alt_operators": [
      {
        "line": 120,
        "operator": "and",
        "replacement": "&&",
        "code": "// valuations to it."
      },
      {
        "line": 177,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 225,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 254,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 345,
        "operator": "and",
        "replacement": "&&",
        "code": "//      {A, G1}, {G1, A, G2}, {G1, B, G2}, {G1, C}, {G1, C, G2}"
      },
      {
        "line": 345,
        "operator": "or",
        "replacement": "||",
        "code": "//      {A, G1}, {G1, A, G2}, {G1, B, G2}, {G1, C}, {G1, C, G2}"
      },
      {
        "line": 350,
        "operator": "and",
        "replacement": "&&",
        "code": "for (size_t j=0; j < (vals.size() - n) + 1; j++)"
      },
      {
        "line": 350,
        "operator": "or",
        "replacement": "||",
        "code": "for (size_t j=0; j < (vals.size() - n) + 1; j++)"
      },
      {
        "line": 354,
        "operator": "and",
        "replacement": "&&",
        "code": "left.insert(left.end(), vars[0]);"
      },
      {
        "line": 354,
        "operator": "or",
        "replacement": "||",
        "code": "left.insert(left.end(), vars[0]);"
      },
      {
        "line": 402,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 548,
        "operator": "and",
        "replacement": "&&",
        "code": "Handle MinerUtils::mk_body(const HandleSeq clauses)"
      },
      {
        "line": 586,
        "operator": "or",
        "replacement": "||",
        "code": "const HandleSeqSeq comps(pl.get_components());"
      },
      {
        "line": 612,
        "operator": "and",
        "replacement": "&&",
        "code": "if (conj)"
      },
      {
        "line": 642,
        "operator": "not",
        "replacement": "!",
        "code": "gl = tmp_query_as->add_link(GET_LINK, vardecl, body);"
      },
      {
        "line": 651,
        "operator": "and",
        "replacement": "&&",
        "code": "HandleSeq hs(qvp->to_handle_seq());"
      },
      {
        "line": 697,
        "operator": "not",
        "replacement": "!",
        "code": "variables.push_back(gen_rand_variable());"
      },
      {
        "line": 719,
        "operator": "or",
        "replacement": "||",
        "code": "vardecl = sc->get_variables().get_vardecl();"
      },
      {
        "line": 728,
        "operator": "or",
        "replacement": "||",
        "code": "return sc->get_body();"
      },
      {
        "line": 768,
        "operator": "not",
        "replacement": "!",
        "code": "HandleSeq clauses = get_clauses(body);"
      },
      {
        "line": 823,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 823,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 841,
        "operator": "not",
        "replacement": "!",
        "code": "Handle r_body = MinerUtils::get_body(r_pat);"
      },
      {
        "line": 900,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 912,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 931,
        "operator": "or",
        "replacement": "||",
        "code": "HandleSeqSeq pseq;"
      },
      {
        "line": 954,
        "operator": "and",
        "replacement": "&&",
        "code": "aconv[var] = nvar;"
      },
      {
        "line": 955,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 955,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      },
      {
        "line": 965,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 975,
        "operator": "not",
        "replacement": "!",
        "code": "and (var_val.second == Unify::CHandle(var)"
      },
      {
        "line": 1145,
        "operator": "not",
        "replacement": "!",
        "code": "const Variables& cvars = get_variables(cnjtion);"
      },
      {
        "line": 1191,
        "operator": "not",
        "replacement": "!",
        "code": "// Base case   //"
      },
      {
        "line": 1298,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 1339,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 1340,
        "operator": "not",
        "replacement": "!",
        "code": "HandleValIntvlMap MinerUtils::simple_unify(const HandleSeq &pat, const HandleSeq &mch)"
      },
      {
        "line": 1353,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 1358,
        "operator": "or",
        "replacement": "||",
        "code": "Handle val = *mch.begin();"
      },
      {
        "line": 1359,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "miner/opencog/miner/Surprisingness.cc": {
    "alt_operators": [
      {
        "line": 402,
        "operator": "and",
        "replacement": "&&",
        "code": "return emp_tv(pattern, db);"
      },
      {
        "line": 414,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 550,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 551,
        "operator": "and",
        "replacement": "&&",
        "code": "TruthValuePtr Surprisingness::ji_tv_est_mem(const Handle& pattern,"
      },
      {
        "line": 567,
        "operator": "and",
        "replacement": "&&",
        "code": "const Variables& lv = LambdaLinkCast(l_pat)->get_variables();"
      },
      {
        "line": 574,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 575,
        "operator": "and",
        "replacement": "&&",
        "code": "bool Surprisingness::is_equivalent(const HandleSeq& l_blk,"
      },
      {
        "line": 716,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      }
    ]
  },
  "miner/opencog/miner/tree.h": {
    "alt_operators": [
      {
        "line": 630,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 631,
        "operator": "not",
        "replacement": "!",
        "code": "template <class T, class tree_node_allocator>"
      }
    ]
  },
  "attention/experiments/ExperimentSetupModule.cc": {
    "alt_operators": [
      {
        "line": 98,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 103,
        "operator": "and",
        "replacement": "&&",
        "code": "if (!outg[0]->isNode() or !outg[1]->isNode())"
      },
      {
        "line": 104,
        "operator": "and",
        "replacement": "&&",
        "code": "return;"
      }
    ]
  },
  "attention/opencog/attention/AttentionParamQuery.cc": {
    "alt_operators": [
      {
        "line": 67,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "attention/opencog/attention/ForgettingAgent.cc": {
    "alt_operators": [
      {
        "line": 72,
        "operator": "and",
        "replacement": "&&",
        "code": "int count = 0;"
      }
    ]
  },
  "attention/opencog/attention/HebbianCreationAgent.cc": {
    "alt_operators": [
      {
        "line": 107,
        "operator": "not",
        "replacement": "!",
        "code": "int count = 0;"
      }
    ]
  },
  "attention/opencog/attention/Neighbors.cc": {
    "alt_operators": [
      {
        "line": 47,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 48,
        "operator": "and",
        "replacement": "&&",
        "code": "for (const Handle& handle : link->getOutgoingSet()) {"
      }
    ]
  },
  "attention/opencog/attentionbank/avalue/AttentionValueOfLink.cc": {
    "alt_operators": [
      {
        "line": 52,
        "operator": "not",
        "replacement": "!",
        "code": "if (nullptr == pr) return AttentionValue::DEFAULT_AV();"
      },
      {
        "line": 72,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 86,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 106,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      }
    ]
  },
  "attention/opencog/attentionbank/bank/AtomBins.cc": {
    "alt_operators": [
      {
        "line": 50,
        "operator": "or",
        "replacement": "||",
        "code": "size_t bins = _idx.size();"
      }
    ]
  },
  "attention/opencog/attentionbank/bank/AttentionBank.cc": {
    "alt_operators": [
      {
        "line": 224,
        "operator": "and",
        "replacement": "&&",
        "code": "if (clip) return std::max(0.0, std::min(val, 1.0));"
      },
      {
        "line": 229,
        "operator": "and",
        "replacement": "&&",
        "code": "// This implementation is pretty hokey, && is a stop-gap until some"
      }
    ]
  },
  "attention/opencog/attentionbank/bank/ImportanceIndex.cc": {
    "alt_operators": [
      {
        "line": 174,
        "operator": "and",
        "replacement": "&&",
        "code": "if (average) {"
      }
    ]
  },
  "asmoses/opencog/asmoses/atomese/interpreter/Interpreter.cc": {
    "alt_operators": [
      {
        "line": 34,
        "operator": "not",
        "replacement": "!",
        "code": ""
      }
    ]
  },
  "asmoses/opencog/asmoses/combo/combo/iostream_combo.h": {
    "alt_operators": [
      {
        "line": 63,
        "operator": "or",
        "replacement": "||",
        "code": "const string_seq& labels=string_seq(),"
      }
    ]
  },
  "asmoses/opencog/asmoses/combo/main/combo-fmt-converter.cc": {
    "alt_operators": [
      {
        "line": 166,
        "operator": "and",
        "replacement": "&&",
        "code": "if (line.empty())"
      },
      {
        "line": 173,
        "operator": "not",
        "replacement": "!",
        "code": "exit(1);"
      },
      {
        "line": 219,
        "operator": "not",
        "replacement": "!",
        "code": "// Parse program options"
      }
    ]
  },
  "asmoses/opencog/asmoses/data/table/table.cc": {
    "alt_operators": [
      {
        "line": 149,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 161,
        "operator": "and",
        "replacement": "&&",
        "code": "string_seq res;"
      },
      {
        "line": 275,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 280,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 311,
        "operator": "not",
        "replacement": "!",
        "code": "for (const string &feat : ignore_features)"
      },
      {
        "line": 395,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 398,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 401,
        "operator": "and",
        "replacement": "&&",
        "code": "const static contin_t epsilon = 1e-12;"
      },
      {
        "line": 585,
        "operator": "and",
        "replacement": "&&",
        "code": "contin_t max)"
      },
      {
        "line": 586,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 649,
        "operator": "and",
        "replacement": "&&",
        "code": "CompressedTable::CompressedTable(const string_seq &labs, const type_tree &tt)"
      },
      {
        "line": 660,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 662,
        "operator": "and",
        "replacement": "&&",
        "code": "void CompressedTable::remove_rows(const set<unsigned> &idxs)"
      },
      {
        "line": 667,
        "operator": "and",
        "replacement": "&&",
        "code": "// iterator index of the CompressedTable from the perspective of an"
      },
      {
        "line": 799,
        "operator": "or",
        "replacement": "||",
        "code": "for (const value_type &v : *this) {"
      },
      {
        "line": 957,
        "operator": "and",
        "replacement": "&&",
        "code": "// Subsample table //"
      },
      {
        "line": 964,
        "operator": "and",
        "replacement": "&&",
        "code": "OC_ASSERT(ot.empty() || tt.empty() || ot.size() == tt.size());"
      }
    ]
  },
  "asmoses/opencog/asmoses/data/table/table.h": {
    "alt_operators": [
      {
        "line": 378,
        "operator": "not",
        "replacement": "!",
        "code": "template<typename Seq>"
      },
      {
        "line": 1160,
        "operator": "and",
        "replacement": "&&",
        "code": "Table filtered(const F &f) const"
      },
      {
        "line": 1171,
        "operator": "and",
        "replacement": "&&",
        "code": "res.ttable = ttable;"
      },
      {
        "line": 1172,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 1173,
        "operator": "or",
        "replacement": "||",
        "code": "// update target_pos"
      },
      {
        "line": 1344,
        "operator": "or",
        "replacement": "||",
        "code": "// \"ioc\" counter counts how often the vertex_seq (Y, X1, ..., Xn)"
      }
    ]
  },
  "asmoses/opencog/asmoses/data/table/table_io.cc": {
    "alt_operators": [
      {
        "line": 875,
        "operator": "not",
        "replacement": "!",
        "code": "OC_ASSERT(0 != tab.otable.size(),"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/deme/deme_expander.cc": {
    "alt_operators": [
      {
        "line": 281,
        "operator": "not",
        "replacement": "!",
        "code": "<< \" : \" << xmplr_seq[i];"
      },
      {
        "line": 338,
        "operator": "not",
        "replacement": "!",
        "code": "* -- A \"representation\", which is an exemplar decordated with knobs,"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/deme/feature_selector.cc": {
    "alt_operators": [
      {
        "line": 277,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 311,
        "operator": "and",
        "replacement": "&&",
        "code": "logger().debug(\"Remove the exemplar feature\");"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/main/demo-problems.cc": {
    "alt_operators": [
      {
        "line": 261,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 311,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 369,
        "operator": "not",
        "replacement": "!",
        "code": "return rc;"
      },
      {
        "line": 483,
        "operator": "not",
        "replacement": "!",
        "code": "// type_tree tt = gen_signature(id::ann_type, 0);"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/main/problem-params.cc": {
    "alt_operators": [
      {
        "line": 1332,
        "operator": "or",
        "replacement": "||",
        "code": "festor_params.ignore_xmplr_features = false;"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/main/problem.cc": {
    "alt_operators": [
      {
        "line": 46,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/main/table-problems.cc": {
    "alt_operators": [
      {
        "line": 105,
        "operator": "not",
        "replacement": "!",
        "code": "stringstream ss;"
      },
      {
        "line": 247,
        "operator": "not",
        "replacement": "!",
        "code": "\"The input table doesn't have the right data types.\""
      },
      {
        "line": 293,
        "operator": "not",
        "replacement": "!",
        "code": "// input nodes"
      },
      {
        "line": 313,
        "operator": "and",
        "replacement": "&&",
        "code": "int as = alphabet_size(tt, pms.ignore_ops);"
      },
      {
        "line": 407,
        "operator": "not",
        "replacement": "!",
        "code": "logger().info() << \"Canonical program tree (non reduced) maximizing precision = \" << tr;"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/metapopulation/ensemble.cc": {
    "alt_operators": [
      {
        "line": 38,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 82,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 151,
        "operator": "and",
        "replacement": "&&",
        "code": "for (size_t i = 0; i < bslen; i++) {"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/metapopulation/merging.cc": {
    "alt_operators": [
      {
        "line": 83,
        "operator": "not",
        "replacement": "!",
        "code": "ss << \"Deme trimmed down, new size: \" << deme.size();"
      },
      {
        "line": 83,
        "operator": "or",
        "replacement": "||",
        "code": "ss << \"Deme trimmed down, new size: \" << deme.size();"
      },
      {
        "line": 174,
        "operator": "not",
        "replacement": "!",
        "code": "/// assumed that these candidates have already be vetted for quality,"
      },
      {
        "line": 208,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 294,
        "operator": "or",
        "replacement": "||",
        "code": "// Discard the truly poor-scoring instances in each deme."
      },
      {
        "line": 295,
        "operator": "or",
        "replacement": "||",
        "code": "trim_down_deme(deme);"
      },
      {
        "line": 296,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 834,
        "operator": "not",
        "replacement": "!",
        "code": "_best_cscore = csc;"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/metapopulation/metapopulation.cc": {
    "alt_operators": [
      {
        "line": 138,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 158,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 367,
        "operator": "not",
        "replacement": "!",
        "code": "size_t fwd = std::distance(probs.begin(), roulette_select(probs.begin(),"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/metapopulation/subsample.cc": {
    "alt_operators": [
      {
        "line": 127,
        "operator": "or",
        "replacement": "||",
        "code": "return ag_dsts[i1] < ag_dsts[i2]; });"
      },
      {
        "line": 128,
        "operator": "or",
        "replacement": "||",
        "code": "worst_idxs.erase(worst_idxs.begin(), worst_idxs.begin() + n_best_bfdemes);"
      },
      {
        "line": 465,
        "operator": "and",
        "replacement": "&&",
        "code": "<< _filter_params.tanimoto_mean_threshold << \")\";"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/moses/distributed_moses.cc": {
    "posix_headers": [
      {
        "line": 31,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 88,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 89,
        "operator": "and",
        "replacement": "&&",
        "code": "string build_cmdline(const boost::program_options::variables_map& vm,"
      },
      {
        "line": 90,
        "operator": "and",
        "replacement": "&&",
        "code": "const combo_tree& tr,"
      },
      {
        "line": 91,
        "operator": "and",
        "replacement": "&&",
        "code": "const string& host_name,"
      },
      {
        "line": 92,
        "operator": "and",
        "replacement": "&&",
        "code": "unsigned n_jobs,"
      },
      {
        "line": 93,
        "operator": "and",
        "replacement": "&&",
        "code": "unsigned max_evals,"
      },
      {
        "line": 94,
        "operator": "and",
        "replacement": "&&",
        "code": "unsigned gen_idx)"
      },
      {
        "line": 95,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 96,
        "operator": "and",
        "replacement": "&&",
        "code": "namespace po = boost::program_options;"
      },
      {
        "line": 97,
        "operator": "and",
        "replacement": "&&",
        "code": "string res;"
      },
      {
        "line": 98,
        "operator": "and",
        "replacement": "&&",
        "code": "if (host_name == localhost)"
      },
      {
        "line": 99,
        "operator": "and",
        "replacement": "&&",
        "code": "res = \"moses\";"
      },
      {
        "line": 100,
        "operator": "and",
        "replacement": "&&",
        "code": "else"
      },
      {
        "line": 101,
        "operator": "and",
        "replacement": "&&",
        "code": "res = string(\"ssh \") + host_name + \" 'moses\";"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/moses/local_moses.cc": {
    "alt_operators": [
      {
        "line": 90,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 91,
        "operator": "and",
        "replacement": "&&",
        "code": "// Might be empty, if the eval fails && throws an exception"
      },
      {
        "line": 92,
        "operator": "and",
        "replacement": "&&",
        "code": "return done || mp.empty();"
      },
      {
        "line": 148,
        "operator": "and",
        "replacement": "&&",
        "code": "gettimeofday(&stop, NULL);"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/moses/moses_main.cc": {
    "alt_operators": [
      {
        "line": 95,
        "operator": "or",
        "replacement": "||",
        "code": "void metapop_printer::operator()(metapopulation &metapop,"
      },
      {
        "line": 137,
        "operator": "or",
        "replacement": "||",
        "code": "//    ss << \" \" <<"
      },
      {
        "line": 255,
        "operator": "and",
        "replacement": "&&",
        "code": "if (very_best_score != moses_params.max_score) {"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/moses/moses_main.h": {
    "alt_operators": [
      {
        "line": 171,
        "operator": "and",
        "replacement": "&&",
        "code": "* Autoscale diversity pressure to match the magnitude of the scorer"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/moses/types.cc": {
    "alt_operators": [
      {
        "line": 31,
        "operator": "and",
        "replacement": "&&",
        "code": "// std::regex will only be implemented in gcc 4.9. Meanwhile we use"
      },
      {
        "line": 32,
        "operator": "and",
        "replacement": "&&",
        "code": "// boost::regex"
      },
      {
        "line": 33,
        "operator": "and",
        "replacement": "&&",
        "code": "#include <boost/regex.hpp>"
      },
      {
        "line": 34,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 39,
        "operator": "and",
        "replacement": "&&",
        "code": "namespace opencog { namespace moses {"
      },
      {
        "line": 40,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 41,
        "operator": "and",
        "replacement": "&&",
        "code": "using namespace std;"
      },
      {
        "line": 42,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 170,
        "operator": "and",
        "replacement": "&&",
        "code": "complexity_penalty = r.complexity_penalty;"
      },
      {
        "line": 170,
        "operator": "or",
        "replacement": "||",
        "code": "complexity_penalty = r.complexity_penalty;"
      },
      {
        "line": 182,
        "operator": "and",
        "replacement": "&&",
        "code": "return !isnan(rig);"
      },
      {
        "line": 183,
        "operator": "and",
        "replacement": "&&",
        "code": "else"
      },
      {
        "line": 184,
        "operator": "and",
        "replacement": "&&",
        "code": "return (lef < rig)"
      },
      {
        "line": 185,
        "operator": "and",
        "replacement": "&&",
        "code": "// Note: I've tried to see if the addition below"
      },
      {
        "line": 221,
        "operator": "and",
        "replacement": "&&",
        "code": "const scored_combo_tree& sct,"
      },
      {
        "line": 249,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/optimization/hill-climbing.cc": {
    "alt_operators": [
      {
        "line": 123,
        "operator": "and",
        "replacement": "&&",
        "code": "// instances are likely to be genetic cross-overs of the"
      },
      {
        "line": 124,
        "operator": "and",
        "replacement": "&&",
        "code": "// current top-scoring instances.  This assumption seems to"
      },
      {
        "line": 125,
        "operator": "and",
        "replacement": "&&",
        "code": "// work really quite well."
      },
      {
        "line": 126,
        "operator": "and",
        "replacement": "&&",
        "code": "//"
      },
      {
        "line": 391,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 391,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 393,
        "operator": "not",
        "replacement": "!",
        "code": "* distance was zero, there was only one instance at"
      },
      {
        "line": 397,
        "operator": "not",
        "replacement": "!",
        "code": "* neighbor with a distance greater than 0 (when the"
      },
      {
        "line": 397,
        "operator": "and",
        "replacement": "&&",
        "code": "* neighbor with a distance greater than 0 (when the"
      },
      {
        "line": 397,
        "operator": "or",
        "replacement": "||",
        "code": "* neighbor with a distance greater than 0 (when the"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/representation/BuildAtomeseKnobs.cc": {
    "alt_operators": [
      {
        "line": 154,
        "operator": "not",
        "replacement": "!",
        "code": "if (prog->get_type() == NOT_LINK) // TODO check if greater_than_link"
      },
      {
        "line": 249,
        "operator": "or",
        "replacement": "||",
        "code": "for (int i = 0; i < _arity; i++) {"
      },
      {
        "line": 294,
        "operator": "not",
        "replacement": "!",
        "code": "logger().debug() << \"perms.size: \" << ps"
      },
      {
        "line": 294,
        "operator": "and",
        "replacement": "&&",
        "code": "logger().debug() << \"perms.size: \" << ps"
      },
      {
        "line": 312,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 312,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 312,
        "operator": "or",
        "replacement": "||",
        "code": "{"
      },
      {
        "line": 314,
        "operator": "not",
        "replacement": "!",
        "code": "bool is_comp = logical_subtree_knob(prog, child, add_if_in_exemplar);"
      },
      {
        "line": 421,
        "operator": "or",
        "replacement": "||",
        "code": ""
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/representation/build_knobs.cc": {
    "alt_operators": [
      {
        "line": 419,
        "operator": "and",
        "replacement": "&&",
        "code": "* If negate is true the argument or the predicate if any is negated."
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/representation/representation.h": {
    "alt_operators": [
      {
        "line": 87,
        "operator": "not",
        "replacement": "!",
        "code": "* get_clean_exemplar. Around for the time being just in case but"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/scoring/bscores.cc": {
    "alt_operators": [
      {
        "line": 500,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/scoring/discriminating_bscore.cc": {
    "alt_operators": [
      {
        "line": 445,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/scoring/precision_bscore.cc": {
    "alt_operators": [
      {
        "line": 134,
        "operator": "or",
        "replacement": "||",
        "code": "TemporalGranularity granularity,"
      },
      {
        "line": 173,
        "operator": "and",
        "replacement": "&&",
        "code": "OC_ASSERT((0.0 < min_activation) && (min_activation <= max_activation),"
      },
      {
        "line": 306,
        "operator": "not",
        "replacement": "!",
        "code": "//"
      },
      {
        "line": 490,
        "operator": "and",
        "replacement": "&&",
        "code": "auto interpret_tr = boost::apply_visitor(iv);"
      },
      {
        "line": 619,
        "operator": "or",
        "replacement": "||",
        "code": "// So before adding the recall penalty we add 0.5 to"
      },
      {
        "line": 775,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/scoring/scoring_base.cc": {
    "alt_operators": [
      {
        "line": 127,
        "operator": "not",
        "replacement": "!",
        "code": "// XXX FIXME complexity_t should be a double ! an int ..."
      },
      {
        "line": 127,
        "operator": "or",
        "replacement": "||",
        "code": "// XXX FIXME complexity_t should be a double ! an int ..."
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/scoring/select_bscore.cc": {
    "alt_operators": [
      {
        "line": 54,
        "operator": "not",
        "replacement": "!",
        "code": "*    window_top = low_val + upper_percentile * (hi_val - low_val)"
      },
      {
        "line": 78,
        "operator": "not",
        "replacement": "!",
        "code": "bool positive) :"
      },
      {
        "line": 78,
        "operator": "and",
        "replacement": "&&",
        "code": "bool positive) :"
      },
      {
        "line": 82,
        "operator": "not",
        "replacement": "!",
        "code": "\"The selection scorer can only be used with contin-valued tables!\");"
      },
      {
        "line": 82,
        "operator": "and",
        "replacement": "&&",
        "code": "\"The selection scorer can only be used with contin-valued tables!\");"
      },
      {
        "line": 88,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 118,
        "operator": "not",
        "replacement": "!",
        "code": "logger().info() << \"select_bscore: lower_percentile = \" << lower_percentile"
      },
      {
        "line": 120,
        "operator": "and",
        "replacement": "&&",
        "code": "<< \" total wieght = \" << total_weight;"
      },
      {
        "line": 121,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 121,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 121,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 154,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 156,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 157,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 157,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 157,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 207,
        "operator": "not",
        "replacement": "!",
        "code": "int i = 0;"
      },
      {
        "line": 209,
        "operator": "and",
        "replacement": "&&",
        "code": "for (const CompressedTable::value_type &io_row : _wrk_ctable) {"
      },
      {
        "line": 210,
        "operator": "not",
        "replacement": "!",
        "code": "// io_row.first = input vector"
      },
      {
        "line": 210,
        "operator": "and",
        "replacement": "&&",
        "code": "// io_row.first = input vector"
      },
      {
        "line": 210,
        "operator": "or",
        "replacement": "||",
        "code": "// io_row.first = input vector"
      },
      {
        "line": 244,
        "operator": "not",
        "replacement": "!",
        "code": "interpreter_visitor iv(tr);"
      },
      {
        "line": 246,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 277,
        "operator": "not",
        "replacement": "!",
        "code": "bs.push_back(-fail);"
      },
      {
        "line": 279,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      }
    ]
  },
  "asmoses/opencog/asmoses/moses/scoring/ss_bscore.cc": {
    "alt_operators": [
      {
        "line": 31,
        "operator": "or",
        "replacement": "||",
        "code": "#include <boost/accumulators/statistics/mean.hpp>"
      }
    ]
  },
  "asmoses/opencog/asmoses/reduct/rules/contin_rules.cc": {
    "alt_operators": [
      {
        "line": 56,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 976,
        "operator": "not",
        "replacement": "!",
        "code": "\"combo_tree node id::plus should ! be childless (reduce_sin).\");"
      }
    ]
  },
  "asmoses/opencog/asmoses/utils/tree.h": {
    "alt_operators": [
      {
        "line": 630,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 631,
        "operator": "not",
        "replacement": "!",
        "code": "template <class T, class tree_node_allocator>"
      }
    ]
  },
  "spacetime/opencog/spacetime/octomap/TimeOctomap.h": {
    "alt_operators": [
      {
        "line": 47,
        "operator": "and",
        "replacement": "&&",
        "code": "typedef std::list<time_pt> time_list;"
      },
      {
        "line": 104,
        "operator": "not",
        "replacement": "!",
        "code": "++it2)"
      },
      {
        "line": 104,
        "operator": "or",
        "replacement": "||",
        "code": "++it2)"
      },
      {
        "line": 365,
        "operator": "and",
        "replacement": "&&",
        "code": "return false;"
      },
      {
        "line": 395,
        "operator": "not",
        "replacement": "!",
        "code": "const time_pt& till_d,"
      },
      {
        "line": 403,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 507,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 509,
        "operator": "not",
        "replacement": "!",
        "code": "const T& ato_target, point3d& dir)"
      }
    ]
  },
  "spacetime/opencog/spacetime/pointmemory/PointMemorySCM.cc": {
    "alt_operators": [
      {
        "line": 337,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 350,
        "operator": "not",
        "replacement": "!",
        "code": "// store timestamps internally, and avoid or minimize this nasty"
      }
    ]
  },
  "learn/attic/run-ull-2019/SchemeEval.cc": {
    "posix_headers": [
      {
        "line": 16,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 276,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 281,
        "operator": "not",
        "replacement": "!",
        "code": "// thread that will never-ever exit. If this thread exits, the bdwgc"
      },
      {
        "line": 557,
        "operator": "not",
        "replacement": "!",
        "code": "*/"
      },
      {
        "line": 595,
        "operator": "not",
        "replacement": "!",
        "code": "(void *) eval_str,"
      },
      {
        "line": 649,
        "operator": "not",
        "replacement": "!",
        "code": "/// This should never-ever need to actually be done atomically, so if"
      },
      {
        "line": 662,
        "operator": "not",
        "replacement": "!",
        "code": "/// This method is meant to be called from a different thread than"
      },
      {
        "line": 781,
        "operator": "and",
        "replacement": "&&",
        "code": "SchemeSmob::ss_set_env_as(_atomspace);"
      },
      {
        "line": 798,
        "operator": "not",
        "replacement": "!",
        "code": "// Restore the outport"
      },
      {
        "line": 798,
        "operator": "and",
        "replacement": "&&",
        "code": "// Restore the outport"
      }
    ]
  },
  "moses/moses/comboreduct/combo/iostream_combo.h": {
    "alt_operators": [
      {
        "line": 64,
        "operator": "or",
        "replacement": "||",
        "code": "output_format fmt = output_format::combo);"
      }
    ]
  },
  "moses/moses/comboreduct/main/combo-fmt-converter.cc": {
    "alt_operators": [
      {
        "line": 141,
        "operator": "and",
        "replacement": "&&",
        "code": "if (line.empty())"
      },
      {
        "line": 179,
        "operator": "not",
        "replacement": "!",
        "code": "// Parse program options"
      }
    ]
  },
  "moses/moses/comboreduct/reduct/contin_rules.cc": {
    "alt_operators": [
      {
        "line": 56,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 976,
        "operator": "not",
        "replacement": "!",
        "code": "\"combo_tree node id::plus should not be childless (reduce_sin).\");"
      }
    ]
  },
  "moses/moses/comboreduct/table/table.cc": {
    "alt_operators": [
      {
        "line": 139,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 151,
        "operator": "and",
        "replacement": "&&",
        "code": "string_seq res;"
      },
      {
        "line": 265,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 270,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 300,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      },
      {
        "line": 386,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 391,
        "operator": "and",
        "replacement": "&&",
        "code": "const static contin_t epsilon = 1e-12;"
      },
      {
        "line": 396,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      },
      {
        "line": 574,
        "operator": "and",
        "replacement": "&&",
        "code": "contin_t max)"
      },
      {
        "line": 575,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 633,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 644,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 646,
        "operator": "and",
        "replacement": "&&",
        "code": "void CTable::remove_rows(const set<unsigned>& idxs)"
      },
      {
        "line": 651,
        "operator": "and",
        "replacement": "&&",
        "code": "// iterator index of the CTable from the perspective of an"
      },
      {
        "line": 783,
        "operator": "or",
        "replacement": "||",
        "code": "for (const value_type& v : *this) {"
      },
      {
        "line": 868,
        "operator": "and",
        "replacement": "&&",
        "code": "// Subsample table //"
      },
      {
        "line": 875,
        "operator": "and",
        "replacement": "&&",
        "code": "OC_ASSERT(ot.empty() || tt.empty() || ot.size() == tt.size());"
      }
    ]
  },
  "moses/moses/comboreduct/table/table.h": {
    "alt_operators": [
      {
        "line": 289,
        "operator": "not",
        "replacement": "!",
        "code": "struct get_type_tree_at_visitor : public boost::static_visitor<type_tree>"
      },
      {
        "line": 977,
        "operator": "and",
        "replacement": "&&",
        "code": "// that container corresponds to the column index of the ITable"
      },
      {
        "line": 988,
        "operator": "and",
        "replacement": "&&",
        "code": "// set timestamp table"
      },
      {
        "line": 989,
        "operator": "or",
        "replacement": "||",
        "code": "res.ttable = ttable;"
      },
      {
        "line": 990,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 1163,
        "operator": "or",
        "replacement": "||",
        "code": "// occurs."
      }
    ]
  },
  "moses/moses/moses/deme/deme_expander.cc": {
    "alt_operators": [
      {
        "line": 284,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 338,
        "operator": "not",
        "replacement": "!",
        "code": "* -- A \"representation\", which is an exemplar decordated with knobs,"
      }
    ]
  },
  "moses/moses/moses/deme/feature_selector.cc": {
    "alt_operators": [
      {
        "line": 277,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      },
      {
        "line": 311,
        "operator": "and",
        "replacement": "&&",
        "code": "logger().debug(\"Remove the exemplar feature\");"
      }
    ]
  },
  "moses/moses/moses/main/demo-problems.cc": {
    "alt_operators": [
      {
        "line": 251,
        "operator": "not",
        "replacement": "!",
        "code": "logger().warn(\"Feature selection is not supported for the polynomial problem\");"
      },
      {
        "line": 300,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 358,
        "operator": "not",
        "replacement": "!",
        "code": "return rc;"
      },
      {
        "line": 464,
        "operator": "not",
        "replacement": "!",
        "code": "check_args(pms);"
      }
    ]
  },
  "moses/moses/moses/main/problem-params.cc": {
    "alt_operators": [
      {
        "line": 1310,
        "operator": "or",
        "replacement": "||",
        "code": "} else if (fs_seed == seed_xmplr) {"
      }
    ]
  },
  "moses/moses/moses/main/problem.cc": {
    "alt_operators": [
      {
        "line": 46,
        "operator": "or",
        "replacement": "||",
        "code": "}"
      }
    ]
  },
  "moses/moses/moses/main/table-problems.cc": {
    "alt_operators": [
      {
        "line": 104,
        "operator": "not",
        "replacement": "!",
        "code": "stringstream ss;"
      },
      {
        "line": 237,
        "operator": "not",
        "replacement": "!",
        "code": "\"The input table doesn't have the right data types.\""
      },
      {
        "line": 285,
        "operator": "not",
        "replacement": "!",
        "code": "// input nodes"
      },
      {
        "line": 305,
        "operator": "and",
        "replacement": "&&",
        "code": "int as = alphabet_size(tt, pms.ignore_ops);"
      },
      {
        "line": 393,
        "operator": "not",
        "replacement": "!",
        "code": "}"
      }
    ]
  },
  "moses/moses/moses/metapopulation/ensemble.cc": {
    "alt_operators": [
      {
        "line": 36,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 79,
        "operator": "and",
        "replacement": "&&",
        "code": "void ensemble::add_candidates(scored_combo_tree_set& cands)"
      },
      {
        "line": 149,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      }
    ]
  },
  "moses/moses/moses/metapopulation/merging.cc": {
    "alt_operators": [
      {
        "line": 84,
        "operator": "not",
        "replacement": "!",
        "code": "logger().debug(ss.str());"
      },
      {
        "line": 84,
        "operator": "or",
        "replacement": "||",
        "code": "logger().debug(ss.str());"
      },
      {
        "line": 148,
        "operator": "not",
        "replacement": "!",
        "code": "/// assumed that these candidates have already be vetted for quality,"
      },
      {
        "line": 232,
        "operator": "or",
        "replacement": "||",
        "code": "// Discard the truly poor-scoring instances in each deme."
      },
      {
        "line": 233,
        "operator": "or",
        "replacement": "||",
        "code": "trim_down_deme(deme);"
      },
      {
        "line": 234,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 598,
        "operator": "not",
        "replacement": "!",
        "code": "{"
      }
    ]
  },
  "moses/moses/moses/metapopulation/metapopulation.cc": {
    "alt_operators": [
      {
        "line": 78,
        "operator": "not",
        "replacement": "!",
        "code": "behavioral_score bs(_cscorer.get_bscore(base));"
      },
      {
        "line": 196,
        "operator": "not",
        "replacement": "!",
        "code": "size_t fwd = std::distance(probs.begin(), roulette_select(probs.begin(),"
      }
    ]
  },
  "moses/moses/moses/metapopulation/subsample.cc": {
    "alt_operators": [
      {
        "line": 127,
        "operator": "or",
        "replacement": "||",
        "code": "return ag_dsts[i1] < ag_dsts[i2]; });"
      },
      {
        "line": 128,
        "operator": "or",
        "replacement": "||",
        "code": "worst_idxs.erase(worst_idxs.begin(), worst_idxs.begin() + n_best_bfdemes);"
      },
      {
        "line": 465,
        "operator": "and",
        "replacement": "&&",
        "code": "<< _filter_params.tanimoto_mean_threshold << \")\";"
      }
    ]
  },
  "moses/moses/moses/moses/distributed_moses.cc": {
    "posix_headers": [
      {
        "line": 27,
        "header": "unistd.h",
        "windows_equiv": [
          "io.h",
          "process.h"
        ],
        "code": "#include <unistd.h>"
      }
    ],
    "alt_operators": [
      {
        "line": 83,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 84,
        "operator": "and",
        "replacement": "&&",
        "code": "string build_cmdline(const boost::program_options::variables_map& vm,"
      },
      {
        "line": 85,
        "operator": "and",
        "replacement": "&&",
        "code": "const combo_tree& tr,"
      },
      {
        "line": 86,
        "operator": "and",
        "replacement": "&&",
        "code": "const string& host_name,"
      },
      {
        "line": 87,
        "operator": "and",
        "replacement": "&&",
        "code": "unsigned n_jobs,"
      },
      {
        "line": 88,
        "operator": "and",
        "replacement": "&&",
        "code": "unsigned max_evals,"
      },
      {
        "line": 89,
        "operator": "and",
        "replacement": "&&",
        "code": "unsigned gen_idx)"
      },
      {
        "line": 90,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      },
      {
        "line": 91,
        "operator": "and",
        "replacement": "&&",
        "code": "namespace po = boost::program_options;"
      },
      {
        "line": 92,
        "operator": "and",
        "replacement": "&&",
        "code": "string res;"
      },
      {
        "line": 93,
        "operator": "and",
        "replacement": "&&",
        "code": "if (host_name == localhost)"
      },
      {
        "line": 94,
        "operator": "and",
        "replacement": "&&",
        "code": "res = \"moses\";"
      },
      {
        "line": 95,
        "operator": "and",
        "replacement": "&&",
        "code": "else"
      },
      {
        "line": 96,
        "operator": "and",
        "replacement": "&&",
        "code": "res = string(\"ssh \") + host_name + \" 'moses\";"
      }
    ]
  },
  "moses/moses/moses/moses/local_moses.cc": {
    "alt_operators": [
      {
        "line": 90,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 91,
        "operator": "and",
        "replacement": "&&",
        "code": "// Might be empty, if the eval fails and throws an exception"
      },
      {
        "line": 92,
        "operator": "and",
        "replacement": "&&",
        "code": "return done || mp.empty();"
      },
      {
        "line": 148,
        "operator": "and",
        "replacement": "&&",
        "code": "gettimeofday(&stop, NULL);"
      }
    ]
  },
  "moses/moses/moses/moses/moses_main.cc": {
    "alt_operators": [
      {
        "line": 80,
        "operator": "and",
        "replacement": "&&",
        "code": "if (very_best_score != moses_params.max_score) {"
      }
    ]
  },
  "moses/moses/moses/moses/moses_main.h": {
    "alt_operators": [
      {
        "line": 90,
        "operator": "or",
        "replacement": "||",
        "code": "/**"
      },
      {
        "line": 136,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 333,
        "operator": "and",
        "replacement": "&&",
        "code": "/**"
      }
    ]
  },
  "moses/moses/moses/moses/types.cc": {
    "alt_operators": [
      {
        "line": 31,
        "operator": "and",
        "replacement": "&&",
        "code": "// std::regex will only be implemented in gcc 4.9. Meanwhile we use"
      },
      {
        "line": 32,
        "operator": "and",
        "replacement": "&&",
        "code": "// boost::regex"
      },
      {
        "line": 33,
        "operator": "and",
        "replacement": "&&",
        "code": "#include <boost/regex.hpp>"
      },
      {
        "line": 34,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 125,
        "operator": "and",
        "replacement": "&&",
        "code": "complexity_penalty = r.complexity_penalty;"
      },
      {
        "line": 125,
        "operator": "or",
        "replacement": "||",
        "code": "complexity_penalty = r.complexity_penalty;"
      },
      {
        "line": 137,
        "operator": "and",
        "replacement": "&&",
        "code": "return !std::isnan(rig);"
      },
      {
        "line": 138,
        "operator": "and",
        "replacement": "&&",
        "code": "else"
      },
      {
        "line": 139,
        "operator": "and",
        "replacement": "&&",
        "code": "return (lef < rig)"
      },
      {
        "line": 140,
        "operator": "and",
        "replacement": "&&",
        "code": "// Note: I've tried to see if the addition below"
      },
      {
        "line": 176,
        "operator": "and",
        "replacement": "&&",
        "code": "const scored_combo_tree& sct,"
      }
    ]
  },
  "moses/moses/moses/optimization/hill-climbing.cc": {
    "alt_operators": [
      {
        "line": 123,
        "operator": "and",
        "replacement": "&&",
        "code": "// instances are likely to be genetic cross-overs of the"
      },
      {
        "line": 124,
        "operator": "and",
        "replacement": "&&",
        "code": "// current top-scoring instances.  This assumption seems to"
      },
      {
        "line": 125,
        "operator": "and",
        "replacement": "&&",
        "code": "// work really quite well."
      },
      {
        "line": 126,
        "operator": "and",
        "replacement": "&&",
        "code": "//"
      },
      {
        "line": 391,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 391,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 393,
        "operator": "not",
        "replacement": "!",
        "code": "* distance was zero, there was only one instance at"
      },
      {
        "line": 397,
        "operator": "not",
        "replacement": "!",
        "code": "* neighbor with a distance greater than 0 (when the"
      },
      {
        "line": 397,
        "operator": "and",
        "replacement": "&&",
        "code": "* neighbor with a distance greater than 0 (when the"
      },
      {
        "line": 397,
        "operator": "or",
        "replacement": "||",
        "code": "* neighbor with a distance greater than 0 (when the"
      }
    ]
  },
  "moses/moses/moses/representation/build_knobs.cc": {
    "alt_operators": [
      {
        "line": 394,
        "operator": "and",
        "replacement": "&&",
        "code": "* If negate is true the argument or the predicate if any is negated."
      }
    ]
  },
  "moses/moses/moses/representation/representation.h": {
    "alt_operators": [
      {
        "line": 88,
        "operator": "not",
        "replacement": "!",
        "code": "void clean_combo_tree(combo_tree &tr, bool reduce,"
      }
    ]
  },
  "moses/moses/moses/scoring/bscores.cc": {
    "alt_operators": [
      {
        "line": 397,
        "operator": "and",
        "replacement": "&&",
        "code": "// workes correctly even for weighted tables, where the counts"
      }
    ]
  },
  "moses/moses/moses/scoring/discriminating_bscore.cc": {
    "alt_operators": [
      {
        "line": 353,
        "operator": "and",
        "replacement": "&&",
        "code": "{"
      }
    ]
  },
  "moses/moses/moses/scoring/precision_bscore.cc": {
    "alt_operators": [
      {
        "line": 124,
        "operator": "or",
        "replacement": "||",
        "code": "TemporalGranularity granularity,"
      },
      {
        "line": 163,
        "operator": "and",
        "replacement": "&&",
        "code": "OC_ASSERT((0.0 < min_activation) && (min_activation <= max_activation),"
      },
      {
        "line": 297,
        "operator": "not",
        "replacement": "!",
        "code": "// By using (tp-fp)/2, the sum of all the per-row contributions"
      },
      {
        "line": 463,
        "operator": "and",
        "replacement": "&&",
        "code": "auto interpret_tr = boost::apply_visitor(iv);"
      },
      {
        "line": 575,
        "operator": "or",
        "replacement": "||",
        "code": "// So before adding the recall penalty we add 0.5 to"
      },
      {
        "line": 733,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      }
    ]
  },
  "moses/moses/moses/scoring/scoring_base.cc": {
    "alt_operators": [
      {
        "line": 108,
        "operator": "not",
        "replacement": "!",
        "code": "// XXX FIXME complexity_t should be a double not an int ..."
      },
      {
        "line": 108,
        "operator": "or",
        "replacement": "||",
        "code": "// XXX FIXME complexity_t should be a double not an int ..."
      }
    ]
  },
  "moses/moses/moses/scoring/select_bscore.cc": {
    "alt_operators": [
      {
        "line": 47,
        "operator": "not",
        "replacement": "!",
        "code": "*    window_top = low_val + upper_percentile * (hi_val - low_val)"
      },
      {
        "line": 71,
        "operator": "not",
        "replacement": "!",
        "code": "bool positive) :"
      },
      {
        "line": 71,
        "operator": "and",
        "replacement": "&&",
        "code": "bool positive) :"
      },
      {
        "line": 75,
        "operator": "not",
        "replacement": "!",
        "code": "\"The selection scorer can only be used with contin-valued tables!\");"
      },
      {
        "line": 75,
        "operator": "and",
        "replacement": "&&",
        "code": "\"The selection scorer can only be used with contin-valued tables!\");"
      },
      {
        "line": 81,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 111,
        "operator": "not",
        "replacement": "!",
        "code": "logger().info() << \"select_bscore: lower_percentile = \" << lower_percentile"
      },
      {
        "line": 113,
        "operator": "and",
        "replacement": "&&",
        "code": "<< \" total wieght = \" << total_weight;"
      },
      {
        "line": 114,
        "operator": "not",
        "replacement": "!",
        "code": ""
      },
      {
        "line": 114,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 114,
        "operator": "or",
        "replacement": "||",
        "code": ""
      },
      {
        "line": 163,
        "operator": "not",
        "replacement": "!",
        "code": "interpreter_visitor iv(tr);"
      },
      {
        "line": 165,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 166,
        "operator": "not",
        "replacement": "!",
        "code": "for (const CTable::value_type& io_row : _wrk_ctable) {"
      },
      {
        "line": 166,
        "operator": "and",
        "replacement": "&&",
        "code": "for (const CTable::value_type& io_row : _wrk_ctable) {"
      },
      {
        "line": 166,
        "operator": "or",
        "replacement": "||",
        "code": "for (const CTable::value_type& io_row : _wrk_ctable) {"
      },
      {
        "line": 200,
        "operator": "not",
        "replacement": "!",
        "code": "interpreter_visitor iv(tr);"
      },
      {
        "line": 202,
        "operator": "and",
        "replacement": "&&",
        "code": ""
      },
      {
        "line": 233,
        "operator": "not",
        "replacement": "!",
        "code": "bs.push_back(-fail);"
      },
      {
        "line": 235,
        "operator": "and",
        "replacement": "&&",
        "code": "}"
      }
    ]
  },
  "moses/moses/moses/scoring/ss_bscore.cc": {
    "alt_operators": [
      {
        "line": 31,
        "operator": "or",
        "replacement": "||",
        "code": "#include <boost/accumulators/statistics/mean.hpp>"
      }
    ]
  },
  "moses/moses/pleasure/pleasure/generation_table.cpp": {
    "alt_operators": [
      {
        "line": 33,
        "operator": "and",
        "replacement": "&&",
        "code": "for (temp = 0; (temp != (int)type_node_list.size()) and (!combo::equal_type_tree(atlist[i], type_node_list[temp])); temp++);"
      }
    ]
  }
}